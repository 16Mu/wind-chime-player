# 播放记录自动刷新 - 测试指南

## 🔧 修复内容

### 问题
- 播放记录不会自动刷新
- 需要手动点击刷新按钮或切换排序方式

### 解决方案
优化了事件监听逻辑，修复了以下问题：
1. ✅ **闭包问题**：useEffect 依赖导致监听器不断重建
2. ✅ **时序问题**：数据库写入和读取的时间差
3. ✅ **状态更新**：直接调用 API 更新状态，避免依赖外部函数

## 📝 关键修改

### `src/contexts/PlayHistoryContext.tsx`

```typescript
// 监听播放器曲目切换事件
useEffect(() => {
  let refreshTimeout: NodeJS.Timeout | null = null;
  let unlistenFn: (() => void) | null = null;
  
  const setupListener = async () => {
    unlistenFn = await listen('player-track-changed', async (event: any) => {
      const trackData = event.payload;
      
      // 1️⃣ 立即记录到数据库
      if (trackData && trackData.id) {
        await invoke('add_play_history', { trackId: trackData.id });
      }
      
      // 2️⃣ 延迟刷新UI（确保数据库已写入）
      refreshTimeout = setTimeout(async () => {
        // 直接调用 API 更新状态
        const historyData = await invoke('get_play_history', {...});
        setHistory(historyData);
        setLastUpdateTime(Date.now());
        
        const stats = await invoke('get_play_statistics');
        setStatistics(stats);
      }, 1500); // 1.5秒延迟
    });
  };
  
  setupListener();
  
  return () => {
    if (refreshTimeout) clearTimeout(refreshTimeout);
    if (unlistenFn) unlistenFn();
  };
}, [sortBy]); // 只依赖 sortBy
```

**关键点**：
- ✅ 正确使用 async/await 设置监听器
- ✅ 直接调用 invoke API，避免闭包
- ✅ 延迟1.5秒刷新，确保数据库写入完成
- ✅ 只依赖 sortBy，避免监听器重建

### `src-tauri/src/lib.rs`

恢复 `player_play` 命令为原始版本，移除数据库记录逻辑：

```rust
#[tauri::command]
async fn player_play(track_id: i64, timestamp: i64) -> Result<(), String> {
    let tx = PLAYER_TX.get().ok_or("Player not initialized")?;
    tx.send(PlayerCommand::Play(track_id, timestamp))
        .map_err(|e| e.to_string())?;
    Ok(())
}
```

**优势**：
- ✅ 播放命令保持简洁
- ✅ 完全解耦，记录失败不影响播放
- ✅ 事件驱动，符合架构设计

## 🧪 测试步骤

### 1. 准备测试环境
```bash
npm run dev
```

### 2. 打开浏览器开发者工具
按 F12 打开控制台，观察日志输出

### 3. 测试自动记录和刷新

#### 测试 A：基本自动刷新
1. 导航到"播放记录"页面
2. 观察控制台输出：
   ```
   [PlayHistoryContext] ✅ 已设置播放历史监听器
   ```
3. 播放一首歌曲
4. 观察控制台输出：
   ```
   [PlayHistoryContext] 🎵 检测到曲目切换: {id: 123, ...}
   [PlayHistoryContext] ✅ 播放历史已记录: track_id= 123
   [PlayHistoryContext] 🔄 刷新播放历史和统计数据
   [PlayHistoryContext] ✅ 数据刷新完成
   ```
5. **预期结果**：
   - ✅ 约1.5秒后，播放记录列表自动更新
   - ✅ 统计数据（总播放次数等）自动更新
   - ✅ 更新时间显示"刚刚更新"

#### 测试 B：快速切歌（防抖测试）
1. 快速连续播放3首歌曲（间隔小于1秒）
2. 观察控制台日志
3. **预期结果**：
   - ✅ 每首歌都记录到数据库
   - ✅ 但只刷新一次UI（最后一首歌后1.5秒）
   - ✅ 播放次数正确累加

#### 测试 C：切换排序方式
1. 在播放记录页面
2. 点击"播放次数"排序
3. 播放一首新歌
4. **预期结果**：
   - ✅ 自动刷新仍然工作
   - ✅ 数据按照"播放次数"排序显示

#### 测试 D：手动刷新
1. 播放一首歌后
2. 不等待自动刷新，立即点击"刷新"按钮
3. **预期结果**：
   - ✅ 立即显示最新数据
   - ✅ 刷新按钮显示旋转动画
   - ✅ 更新时间更新

### 4. 验证数据准确性

#### 检查播放次数
1. 同一首歌播放3次
2. 检查播放记录中该歌曲的"播放次数"
3. **预期结果**：显示 "3 次"

#### 检查统计数据
1. 播放5首不同的歌曲
2. 检查顶部统计卡片
3. **预期结果**：
   - 总播放次数：5
   - 不同曲目：5
   - 总播放时长：正确累加

## 📊 日志输出示例

### 正常工作的日志
```
[PlayHistoryContext] ✅ 已设置播放历史监听器
[PlayHistoryContext] 🎵 检测到曲目切换: {id: 456, title: "Breathe", artist: "kenzie"}
[PlayHistoryContext] ✅ 播放历史已记录: track_id= 456
[PlayHistoryContext] 🔄 刷新播放历史和统计数据
[PlayHistoryContext] ✅ 数据刷新完成
```

### 异常情况的日志
```
[PlayHistoryContext] ⚠️ 记录播放历史失败: [错误信息]
[PlayHistoryContext] ❌ 刷新数据失败: [错误信息]
```

## 🐛 常见问题排查

### 问题1：播放后没有任何日志输出
**原因**：监听器未正确设置
**解决**：
1. 检查 PlayHistoryProvider 是否正确包裹了组件
2. 刷新页面重新初始化

### 问题2：看到"检测到曲目切换"，但数据未更新
**原因**：数据库操作失败或 API 调用失败
**解决**：
1. 查看控制台是否有错误日志
2. 检查后端服务是否正常运行

### 问题3：数据延迟很久才更新
**原因**：1.5秒延迟 + 数据库操作时间
**解决**：
1. 这是正常现象（防抖 + 确保数据写入）
2. 如需立即查看，点击"刷新"按钮

### 问题4：频繁切歌时数据丢失
**原因**：不应该发生，每次切歌都会记录
**解决**：
1. 检查控制台日志，确认每次都有"✅ 播放历史已记录"
2. 如果某次没有，查看错误日志

## ✅ 验收标准

- [ ] 播放歌曲后，约1.5秒自动刷新播放记录
- [ ] 控制台输出完整的日志链路
- [ ] 播放次数、统计数据准确
- [ ] 快速切歌时，防抖正常工作
- [ ] 切换排序方式后，自动刷新仍然工作
- [ ] 手动刷新按钮正常工作
- [ ] 更新时间显示正确
- [ ] 记录失败不影响播放功能

## 📝 后续优化建议

1. **性能优化**：如果数据量很大，考虑虚拟滚动
2. **用户体验**：添加刷新中的加载提示（subtle）
3. **错误处理**：添加重试机制
4. **离线支持**：缓存最近的播放记录


