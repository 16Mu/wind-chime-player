# 🏗️ 歌单系统架构设计文档

## 📋 目录

1. [设计原则](#设计原则)
2. [架构概览](#架构概览)
3. [模块设计](#模块设计)
4. [数据流](#数据流)
5. [性能优化](#性能优化)
6. [安全性](#安全性)

---

## 设计原则

### 1. 高内聚低耦合

#### 后端（Rust）

**高内聚**：
- `manager.rs` - 所有业务逻辑集中在PlaylistManager
- `smart_playlist.rs` - 智能歌单引擎独立封装
- `exporter.rs` / `importer.rs` - 导入导出功能独立

**低耦合**：
- PlaylistManager **依赖抽象**（Database trait），而非具体实现
- 通过Tauri Command接口与前端交互
- 模块间通过明确的公共API通信

```rust
// ✅ 好的设计：依赖抽象
pub struct PlaylistManager {
    db: Arc<Mutex<Database>>, // 可以替换为任何实现
}

// ❌ 坏的设计：依赖具体实现
pub struct PlaylistManager {
    sqlite_conn: SqliteConnection, // 紧耦合
}
```

#### 前端（React）

**高内聚**：
- `PlaylistContext` - 所有歌单状态和API调用集中
- 每个组件只负责一个功能

**低耦合**：
- 组件通过Props接收数据，不直接访问Context
- 使用事件上报而非直接调用父组件方法
- 展示组件与逻辑组件分离

```tsx
// ✅ 好的设计：纯展示组件
const PlaylistCard = ({ playlist, onClick, onFavorite }) => {
  // 只负责展示，不包含业务逻辑
};

// ❌ 坏的设计：包含业务逻辑
const PlaylistCard = ({ playlistId }) => {
  const data = usePlaylist(); // 紧耦合
  const handleDelete = async () => {
    await invoke('delete_playlist'); // 直接调用API
  };
};
```

### 2. 单一职责原则

每个模块/组件只负责一个功能：

| 模块 | 职责 |
|------|------|
| `manager.rs` | 歌单业务逻辑 |
| `smart_playlist.rs` | 规则解析和执行 |
| `exporter.rs` | 导出功能 |
| `PlaylistContext` | 状态管理和API封装 |
| `PlaylistCard` | 展示单个歌单 |
| `PlaylistsView` | 协调列表展示 |

### 3. 依赖倒置原则

高层模块不依赖低层模块，都依赖抽象：

```rust
// 抽象层
pub trait PlaylistRepository {
    fn create(&self, playlist: Playlist) -> Result<i64>;
    fn get(&self, id: i64) -> Result<Playlist>;
}

// 高层模块依赖抽象
pub struct PlaylistManager<R: PlaylistRepository> {
    repo: R,
}

// 低层模块实现抽象
impl PlaylistRepository for Database {
    // ...
}
```

---

## 架构概览

```
┌─────────────────────────────────────────────────────────────┐
│                         前端层                                │
│                    (React/TypeScript)                        │
├─────────────────────────────────────────────────────────────┤
│  UI Components                Context API                    │
│  ┌──────────────┐           ┌────────────────┐             │
│  │ PlaylistCard │◄──────────┤PlaylistContext │             │
│  │ PlaylistsView│           │  - State       │             │
│  │ PlaylistDetail           │  - Actions     │             │
│  └──────────────┘           └────────────────┘             │
│                                    │                          │
│                                    ▼                          │
│                             Tauri Invoke API                 │
└─────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────┐
│                      Tauri Command Layer                      │
│                         (lib.rs)                             │
│  ┌────────────────────────────────────────────────────────┐ │
│  │  playlists_create, playlists_update, playlists_delete  │ │
│  │  playlists_export, playlists_import, ...               │ │
│  └────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────┐
│                         业务逻辑层                            │
│                      (playlist/manager.rs)                   │
│  ┌────────────────────────────────────────────────────────┐ │
│  │                   PlaylistManager                       │ │
│  │  - create_playlist()                                    │ │
│  │  - update_playlist()                                    │ │
│  │  - delete_playlist()                                    │ │
│  │  - refresh_smart_playlist()                             │ │
│  └────────────────────────────────────────────────────────┘ │
│         │                        │                           │
│         ├────────────────────────┤                          │
│         ▼                        ▼                           │
│  ┌─────────────┐         ┌──────────────┐                  │
│  │SmartPlaylist│         │  Exporter/   │                  │
│  │   Engine    │         │  Importer    │                  │
│  └─────────────┘         └──────────────┘                  │
└─────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────┐
│                         数据访问层                            │
│                          (db.rs)                             │
│  ┌────────────────────────────────────────────────────────┐ │
│  │                      Database                           │ │
│  │  - create_playlist_extended()                           │ │
│  │  - get_all_playlists_extended()                         │ │
│  │  - update_playlist_metadata()                           │ │
│  └────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
                              SQLite Database
```

---

## 模块设计

### 后端模块

#### 1. playlist/types.rs

**职责**：类型定义和数据结构

```rust
pub struct Playlist {
    pub id: i64,
    pub name: String,
    pub is_smart: bool,
    pub smart_rules: Option<String>,
    // ...
}

pub struct SmartRules {
    pub rules: Vec<SmartRule>,
    pub match_all: bool,
    pub limit: Option<i64>,
}
```

**设计要点**：
- 所有字段都有明确的类型
- 使用Option表示可选字段
- 实现Serialize/Deserialize用于JSON序列化

#### 2. playlist/manager.rs

**职责**：核心业务逻辑

**关键方法**：
```rust
impl PlaylistManager {
    pub fn new(db: Arc<Mutex<Database>>) -> Self;
    pub fn create_playlist(&self, options: CreatePlaylistOptions) -> Result<i64>;
    pub fn update_playlist(&self, id: i64, options: UpdatePlaylistOptions) -> Result<()>;
    pub fn delete_playlist(&self, id: i64) -> Result<()>;
    pub fn refresh_smart_playlist(&self, id: i64) -> Result<()>;
}
```

**设计要点**：
- 所有方法都返回Result处理错误
- 使用Arc<Mutex<>>实现线程安全
- 自动刷新智能歌单

#### 3. playlist/smart_playlist.rs

**职责**：智能规则解析和执行

```rust
pub struct SmartPlaylistEngine;

impl SmartPlaylistEngine {
    pub fn filter_tracks(tracks: &[Track], rules: &SmartRules) -> Result<Vec<Track>>;
    pub fn build_sql_where_clause(rules: &SmartRules) -> Option<(String, Vec<String>)>;
}
```

**设计要点**：
- 支持AND/OR逻辑
- 优化SQL查询
- 支持多种字段类型（字符串、数字、日期、布尔）

### 前端模块

#### 1. contexts/PlaylistContext.tsx

**职责**：全局状态管理

**状态**：
```typescript
playlists: Playlist[]           // 所有歌单
currentPlaylist: PlaylistWithTracks | null  // 当前详情
loading: boolean                // 加载状态
error: string | null           // 错误信息
stats: PlaylistStats | null    // 统计信息
```

**方法**：
- CRUD操作
- 智能歌单管理
- 导入导出
- 统计查询

**设计要点**：
- 使用useCallback避免不必要的重新渲染
- 统一错误处理
- 自动刷新相关状态

#### 2. components/playlist/PlaylistCard.tsx

**职责**：展示单个歌单卡片

**Props**：
```typescript
{
  playlist: Playlist;
  onClick?: () => void;
  onFavoriteToggle?: () => void;
  className?: string;
}
```

**设计要点**：
- 纯展示组件，无业务逻辑
- 通过Props接收所有数据
- 通过回调报告用户操作

---

## 数据流

### 创建歌单流程

```
1. 用户点击"创建"按钮
   │
   ▼
2. 显示CreatePlaylistDialog
   │
   ▼
3. 用户填写表单并提交
   │
   ▼
4. 调用Context.createPlaylist()
   │
   ▼
5. invoke('playlists_create', options)
   │
   ▼
6. Rust: playlists_create命令
   │
   ▼
7. PlaylistManager.create_playlist()
   │
   ▼
8. Database.create_playlist_extended()
   │
   ▼
9. SQLite INSERT操作
   │
   ▼
10. 返回playlist_id
   │
   ▼
11. Context自动刷新列表
   │
   ▼
12. UI更新显示新歌单
```

### 智能歌单刷新流程

```
1. 用户点击"刷新"或规则变更
   │
   ▼
2. Context.refreshSmartPlaylist(id)
   │
   ▼
3. PlaylistManager.refresh_smart_playlist()
   │
   ▼
4. 获取歌单和规则
   │
   ▼
5. SmartPlaylistEngine.filter_tracks()
   │
   ├─► 应用规则筛选
   │
   ├─► 应用AND/OR逻辑
   │
   └─► 应用limit限制
   │
   ▼
6. 清空现有曲目
   │
   ▼
7. 添加筛选后的曲目
   │
   ▼
8. 更新updated_at时间戳
   │
   ▼
9. Context刷新列表和详情
   │
   ▼
10. UI更新显示
```

---

## 性能优化

### 1. 数据库层

**索引优化**：
```sql
CREATE INDEX idx_playlists_is_smart ON playlists(is_smart);
CREATE INDEX idx_playlists_is_favorite ON playlists(is_favorite);
CREATE INDEX idx_playlist_items_playlist_id ON playlist_items(playlist_id);
```

**查询优化**：
```sql
-- 使用JOIN和GROUP BY一次性获取歌单和统计信息
SELECT p.*, COUNT(pi.id) as track_count, COALESCE(SUM(t.duration_ms), 0) as total_duration
FROM playlists p
LEFT JOIN playlist_items pi ON p.id = pi.playlist_id
LEFT JOIN tracks t ON pi.track_id = t.id
GROUP BY p.id;
```

### 2. 前端层

**useMemo缓存计算结果**：
```tsx
const filteredPlaylists = useMemo(() => {
  return playlists.filter(/* ... */);
}, [playlists, filterCriteria]);
```

**useCallback避免重新创建函数**：
```tsx
const handleClick = useCallback(() => {
  // ...
}, [dependencies]);
```

**虚拟滚动（大列表）**：
```tsx
// 使用react-window或react-virtualized
import { FixedSizeList } from 'react-window';
```

### 3. 智能歌单优化

**SQL优先**：
```rust
// 优先使用SQL查询而非内存筛选
if let Some((where_clause, params)) = SmartPlaylistEngine::build_sql_where_clause(rules) {
    // 使用SQL查询
} else {
    // 回退到内存筛选
}
```

---

## 安全性

### 1. SQL注入防护

**✅ 使用参数化查询**：
```rust
stmt.execute(params![playlist_id, track_id])?;
```

**❌ 不要拼接SQL**：
```rust
// 危险！
let sql = format!("DELETE FROM playlists WHERE id = {}", id);
```

### 2. 输入验证

```rust
// 后端验证
if name.len() > 100 {
    return Err(anyhow::anyhow!("名称过长"));
}

// 前端验证
if (!name.trim()) {
    errors.name = '请输入歌单名称';
}
```

### 3. 权限控制

```rust
// 检查用户权限（如果需要）
if !user.can_delete_playlist(playlist_id) {
    return Err(anyhow::anyhow!("无权限"));
}
```

---

## 测试策略

### 单元测试（Rust）

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_filter_by_artist() {
        let tracks = vec![/* ... */];
        let rules = SmartRules {
            rules: vec![SmartRule {
                field: RuleField::Artist,
                operator: RuleOperator::Equals,
                value: "Artist A".to_string(),
            }],
            match_all: true,
            limit: None,
        };

        let filtered = SmartPlaylistEngine::filter_tracks(&tracks, &rules).unwrap();
        assert_eq!(filtered.len(), 2);
    }
}
```

### 集成测试（React）

```tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { PlaylistProvider } from './contexts/PlaylistContext';
import { PlaylistsView } from './components/playlist';

test('创建歌单流程', async () => {
  render(
    <PlaylistProvider>
      <PlaylistsView />
    </PlaylistProvider>
  );

  // 点击创建按钮
  fireEvent.click(screen.getByText('创建歌单'));
  
  // 填写表单
  fireEvent.change(screen.getByPlaceholderText('歌单名称'), {
    target: { value: '测试歌单' }
  });
  
  // 提交
  fireEvent.click(screen.getByText('创建'));
  
  // 验证结果
  await screen.findByText('测试歌单');
});
```

---

**文档完成！** 🎉

