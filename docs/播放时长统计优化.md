# 播放时长统计优化 - 实际播放时长追踪

## 🎯 问题描述

### 原有问题
- **错误行为**：统计使用歌曲的完整时长，而非实际播放时长
- **场景示例**：
  - 一首歌3分钟，用户只听了3秒就切歌
  - 系统统计：3分钟 ❌
  - 应该统计：3秒 ✅

## ✅ 解决方案

### 核心设计
通过监听播放器位置变化事件，精确追踪每首歌的实际播放时长。

```
开始播放 ➜ 记录trackId + 起始时间
    ↓
持续监听 ➜ 更新当前播放位置
    ↓
切换/停止 ➜ 记录实际播放时长 ➜ 刷新统计
```

## 📊 数据库Schema扩展

### `play_history` 表
```sql
CREATE TABLE play_history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    track_id INTEGER NOT NULL,
    played_at INTEGER NOT NULL,
    duration_played_ms INTEGER DEFAULT 0,  -- 新增：实际播放时长（毫秒）
    FOREIGN KEY (track_id) REFERENCES tracks(id) ON DELETE CASCADE
);
```

**迁移逻辑**：
```sql
-- 自动为已存在的表添加字段
ALTER TABLE play_history ADD COLUMN duration_played_ms INTEGER DEFAULT 0;
```

## 🦀 后端实现

### 1. 数据库方法

#### 记录播放历史
```rust
pub fn add_play_history(&self, track_id: i64, duration_played_ms: i64) -> Result<()> {
    let now = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap()
        .as_secs() as i64;
    
    self.conn.execute(
        "INSERT INTO play_history (track_id, played_at, duration_played_ms) VALUES (?1, ?2, ?3)",
        params![track_id, now, duration_played_ms],
    )?;
    Ok(())
}
```

#### 统计查询
```rust
pub fn get_play_statistics(&self) -> Result<(i64, i64, i64)> {
    // 总播放次数
    let total_plays: i64 = self.conn.query_row(
        "SELECT COUNT(*) FROM play_history",
        [], |row| row.get(0)
    )?;
    
    // 不同曲目数
    let unique_tracks: i64 = self.conn.query_row(
        "SELECT COUNT(DISTINCT track_id) FROM play_history",
        [], |row| row.get(0)
    )?;
    
    // ✅ 使用实际播放时长而非曲目完整时长
    let total_duration_ms: i64 = self.conn.query_row(
        "SELECT COALESCE(SUM(duration_played_ms), 0) FROM play_history",
        [], |row| row.get(0)
    )?;
    
    Ok((total_plays, unique_tracks, total_duration_ms))
}
```

### 2. Tauri命令

```rust
#[tauri::command]
async fn add_play_history(
    track_id: i64, 
    duration_played_ms: i64,  // 新增参数
    state: State<'_, AppState>
) -> Result<(), String> {
    let db = state.inner().db.lock().map_err(|e| e.to_string())?;
    db.add_play_history(track_id, duration_played_ms)
        .map_err(|e| e.to_string())
}
```

## 📱 前端实现

### PlayHistoryContext 核心逻辑

#### 1. 状态跟踪
```typescript
// 用 ref 跟踪当前播放信息（避免触发重渲染）
const currentPlayingRef = useRef<{
  trackId: number;
  startTime: number;
  lastPosition: number;  // 实时播放位置（毫秒）
} | null>(null);
```

#### 2. 监听器设置

**监听曲目切换**：
```typescript
unlistenTrackChanged = await listen('player-track-changed', async (event) => {
  const trackData = event.payload;
  
  // 1️⃣ 如果有上一首歌，先记录它的播放时长
  if (currentPlayingRef.current) {
    const playedDuration = currentPlayingRef.current.lastPosition;
    await recordPreviousTrack(playedDuration);
  }
  
  // 2️⃣ 记录新曲目的开始信息
  if (trackData && trackData.id) {
    currentPlayingRef.current = {
      trackId: trackData.id,
      startTime: Date.now(),
      lastPosition: 0,
    };
  }
  
  // 3️⃣ 延迟刷新UI
  setTimeout(async () => {
    // 刷新历史列表和统计数据
  }, 1500);
});
```

**监听播放位置**：
```typescript
unlistenPosition = await listen('player-position-changed', (event) => {
  const positionMs = event.payload as number;
  // 持续更新当前播放位置
  if (currentPlayingRef.current) {
    currentPlayingRef.current.lastPosition = positionMs;
  }
});
```

#### 3. 记录播放历史

```typescript
const recordPreviousTrack = useCallback(async (durationMs: number) => {
  const current = currentPlayingRef.current;
  if (!current) return;
  
  console.log(`📝 记录播放: track_id=${current.trackId}, 时长=${durationMs}ms (${(durationMs/1000).toFixed(1)}秒)`);
  
  await invoke('add_play_history', { 
    trackId: current.trackId, 
    durationPlayedMs: durationMs  // 实际播放时长
  });
}, []);
```

#### 4. 清理逻辑

```typescript
return () => {
  // 组件卸载时，记录当前正在播放的曲目
  if (currentPlayingRef.current) {
    const playedDuration = currentPlayingRef.current.lastPosition;
    if (playedDuration > 0) {
      recordPreviousTrack(playedDuration);
    }
  }
  // 清理监听器
  if (unlistenTrackChanged) unlistenTrackChanged();
  if (unlistenPosition) unlistenPosition();
};
```

## 🔄 工作流程

### 场景1：正常切歌
```
用户播放歌曲A
  ↓
position-changed事件持续更新 (0ms → 1000ms → 2000ms → 3000ms)
  ↓
用户切换到歌曲B
  ↓
track-changed事件触发
  ↓
记录歌曲A: duration_played_ms = 3000ms ✅
  ↓
开始跟踪歌曲B
```

### 场景2：快速切歌
```
用户播放歌曲A
  ↓
position: 0ms → 500ms → 1200ms
  ↓
用户切换到歌曲B (只听了1.2秒)
  ↓
记录歌曲A: duration_played_ms = 1200ms ✅ (而非完整的3分钟)
  ↓
position: 0ms → 2000ms
  ↓
用户切换到歌曲C
  ↓
记录歌曲B: duration_played_ms = 2000ms ✅
```

### 场景3：应用关闭
```
用户正在播放歌曲A
  ↓
position: 0ms → 5000ms → 10000ms
  ↓
用户关闭应用
  ↓
cleanup函数触发
  ↓
记录歌曲A: duration_played_ms = 10000ms ✅
```

## 📊 数据对比

### 优化前
```
歌曲: "Breathe" (duration_ms: 208000)
实际播放: 3秒就切歌了
统计结果: 208000ms (3分28秒) ❌
```

### 优化后
```
歌曲: "Breathe" (duration_ms: 208000)
实际播放: 3秒就切歌了
统计结果: 3000ms (3秒) ✅
```

## 🧪 测试场景

### 测试1：短时播放
1. 播放一首3分钟的歌曲
2. 播放5秒后切歌
3. **验证**：播放记录显示 ~5秒

### 测试2：完整播放
1. 播放一首3分钟的歌曲
2. 完整听完
3. **验证**：播放记录显示 ~3分钟

### 测试3：多次快速切歌
1. 连续播放5首歌，每首只听3-5秒
2. **验证**：
   - 播放次数：5次
   - 累计时长：约15-25秒（而非歌曲总时长）

### 测试4：统计数据准确性
1. 播放3首歌：
   - 歌曲A (3分钟) - 听了10秒
   - 歌曲B (4分钟) - 听了完整的4分钟
   - 歌曲C (5分钟) - 听了30秒
2. **验证**：
   - 总播放次数：3
   - 累计时长：10秒 + 4分钟 + 30秒 = 4分40秒 ✅

## 📝 日志输出示例

### 正常工作日志
```
[PlayHistoryContext] 🎵 检测到曲目切换: {id: 123, title: "Song A"}
[PlayHistoryContext] 📝 记录播放: track_id=122, 时长=3245ms (3.2秒)
[PlayHistoryContext] ✅ 播放历史已记录
[PlayHistoryContext] 🆕 开始跟踪新曲目: 123
[PlayHistoryContext] 🔄 刷新播放历史和统计数据
[PlayHistoryContext] ✅ 数据刷新完成
```

### 快速切歌日志
```
[PlayHistoryContext] 🎵 检测到曲目切换: {id: 124}
[PlayHistoryContext] 📝 记录播放: track_id=123, 时长=892ms (0.9秒)  ✅ 只听了不到1秒
[PlayHistoryContext] ✅ 播放历史已记录
```

## ✨ 优化效果

### 数据准确性
- ✅ 精确记录每首歌的实际播放时长
- ✅ 统计数据反映真实听歌习惯
- ✅ 支持快速切歌场景

### 用户体验
- ✅ 播放时长统计更有意义
- ✅ 能看出真正喜欢的歌曲（播放时长长）
- ✅ 数据分析更准确

### 性能影响
- ✅ position-changed 事件仅更新 ref，不触发重渲染
- ✅ 记录操作异步执行，不阻塞UI
- ✅ 防抖机制避免频繁刷新

## 🔍 技术亮点

1. **精确追踪**：监听 `player-position-changed` 事件，实时更新播放位置
2. **无性能损耗**：使用 `useRef` 而非 `useState`，避免频繁重渲染
3. **完整覆盖**：处理切歌、关闭应用等所有场景
4. **降级兼容**：已有数据自动迁移（默认0ms）

## 📋 修改文件清单

### 后端
- ✅ `src-tauri/src/db.rs`
  - 添加 `duration_played_ms` 字段到 schema
  - 添加字段迁移逻辑
  - 修改 `add_play_history` 方法
  - 修改 `get_play_statistics` 查询

- ✅ `src-tauri/src/lib.rs`
  - 修改 `add_play_history` 命令接受时长参数

### 前端
- ✅ `src/contexts/PlayHistoryContext.tsx`
  - 添加 `currentPlayingRef` 跟踪当前播放
  - 添加 `recordPreviousTrack` 方法
  - 监听 `player-position-changed` 事件
  - 修改 `player-track-changed` 事件处理
  - 添加清理逻辑

## 🎯 验收标准

- [ ] 短时播放（<10秒）统计准确
- [ ] 完整播放统计准确
- [ ] 快速切歌每首都记录正确时长
- [ ] 关闭应用前记录当前播放
- [ ] 控制台日志显示实际播放时长
- [ ] 统计数据中"总播放时长"准确
- [ ] 性能无明显影响（使用ref避免重渲染）

## 🚀 后续优化建议

1. **暂停处理**：当前只统计播放时长，未扣除暂停时间
2. **最小播放时长**：可设置阈值（如<3秒不记录）
3. **播放完成度**：记录播放进度百分比
4. **播放模式分析**：分析用户是否经常跳过某些歌曲


