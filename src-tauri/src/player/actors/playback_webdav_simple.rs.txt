// ç®€åŒ–ç‰ˆ WebDAV æ’­æ”¾å®ç°ï¼ˆå®Œæ•´ä¸‹è½½æ–¹æ¡ˆï¼‰
// å¤åˆ¶è¿™æ®µä»£ç æ›¿æ¢ playback_actor.rs ä¸­çš„ decode_streaming å‡½æ•°

/// WebDAVå®Œæ•´ä¸‹è½½æ’­æ”¾ï¼ˆæ–¹æ¡ˆï¼šå…ˆä¸‹è½½å†æ’­æ”¾ï¼Œæ”¯æŒå®Œç¾seekï¼‰
async fn decode_streaming(&self, track_path: &str) -> Result<Box<dyn rodio::Source<Item = i16> + Send>> {
    use tokio::time::{timeout, Duration};
    
    log::info!("ğŸŒ WebDAV: ä½¿ç”¨å®Œæ•´ä¸‹è½½æ¨¡å¼");
    println!("ğŸŒ [PlaybackActor] WebDAV å®Œæ•´ä¸‹è½½æ¨¡å¼");
    
    // åªæ”¯æŒWEBDAV
    if !track_path.starts_with("webdav://") {
        return Err(PlayerError::decode_error("ä¸æ”¯æŒçš„åè®®".to_string()));
    }
    
    // è§£æWEBDAV URLï¼ˆåŒ…å«å®Œæ•´é…ç½®ï¼‰
    let (http_url, username, password, http_protocol) = self.parse_webdav_url_with_config(track_path)?;
    
    log::info!("ğŸ“¡ WEBDAV HTTP URL: {}", http_url);
    println!("ğŸ“¡ [PlaybackActor] å¼€å§‹ä¸‹è½½: {}", http_url);
    
    // åˆ›å»ºHTTPå®¢æˆ·ç«¯
    let mut client_builder = reqwest::Client::builder()
        .timeout(Duration::from_secs(60));
    
    // æ ¹æ®åè®®åå¥½é…ç½®
    use crate::webdav::types::HttpProtocolPreference;
    client_builder = match http_protocol {
        HttpProtocolPreference::Http1Only => client_builder.http1_only(),
        HttpProtocolPreference::Http2Preferred => client_builder.http2_prior_knowledge(),
        HttpProtocolPreference::Auto => client_builder,
    };
    
    let client = client_builder.build()
        .map_err(|e| PlayerError::decode_error(format!("åˆ›å»ºå®¢æˆ·ç«¯å¤±è´¥: {}", e)))?;
    
    // æ„å»ºè¯·æ±‚
    let mut request = client.get(&http_url);
    
    // æ·»åŠ è®¤è¯
    if !username.is_empty() {
        use base64::Engine;
        let auth_value = format!("{}:{}", username, password);
        let encoded = base64::engine::general_purpose::STANDARD.encode(auth_value.as_bytes());
        request = request.header("Authorization", format!("Basic {}", encoded));
    }
    
    // å‘é€è¯·æ±‚å¹¶ä¸‹è½½
    println!("â¬ [PlaybackActor] å‘é€ä¸‹è½½è¯·æ±‚...");
    let download_start = std::time::Instant::now();
    
    let response = timeout(Duration::from_secs(30), request.send())
        .await
        .map_err(|_| PlayerError::decode_error("ä¸‹è½½è¯·æ±‚è¶…æ—¶".to_string()))?
        .map_err(|e| PlayerError::decode_error(format!("ä¸‹è½½è¯·æ±‚å¤±è´¥: {}", e)))?;
    
    if !response.status().is_success() {
        return Err(PlayerError::decode_error(
            format!("HTTPé”™è¯¯: {}", response.status())
        ));
    }
    
    // è·å–æ–‡ä»¶å¤§å°ï¼ˆç”¨äºæ˜¾ç¤ºè¿›åº¦ï¼‰
    let content_length = response.content_length();
    if let Some(len) = content_length {
        println!("ğŸ“¦ [PlaybackActor] æ–‡ä»¶å¤§å°: {:.2}MB", len as f64 / 1024.0 / 1024.0);
    }
    
    // è¯»å–å®Œæ•´æ•°æ®
    println!("ğŸ“¥ [PlaybackActor] è¯»å–æ•°æ®...");
    let bytes = timeout(Duration::from_secs(120), response.bytes())
        .await
        .map_err(|_| PlayerError::decode_error("è¯»å–æ•°æ®è¶…æ—¶".to_string()))?
        .map_err(|e| PlayerError::decode_error(format!("è¯»å–æ•°æ®å¤±è´¥: {}", e)))?;
    
    let elapsed = download_start.elapsed();
    println!("âœ… [PlaybackActor] ä¸‹è½½å®Œæˆ: {:.2}MB, è€—æ—¶: {:.1}ç§’", 
        bytes.len() as f64 / 1024.0 / 1024.0,
        elapsed.as_secs_f32()
    );
    
    log::info!("âœ… WebDAVä¸‹è½½å®Œæˆ: {} å­—èŠ‚", bytes.len());
    
    // ä»å†…å­˜è§£ç 
    println!("ğŸµ [PlaybackActor] å¼€å§‹è§£ç ...");
    let cursor = std::io::Cursor::new(bytes);
    let decoder = rodio::Decoder::new(cursor)
        .map_err(|e| {
            let err_msg = format!("è§£ç å¤±è´¥: {}", e);
            log::error!("âŒ {}", err_msg);
            println!("âŒ [PlaybackActor] {}", err_msg);
            PlayerError::decode_error(err_msg)
        })?;
    
    println!("âœ… [PlaybackActor] è§£ç æˆåŠŸï¼Œå‡†å¤‡æ’­æ”¾");
    log::info!("âœ… è§£ç å™¨åˆ›å»ºæˆåŠŸ");
    
    Ok(Box::new(decoder))
}



















