use crate::db::Database;
use crate::player::Track;
use anyhow::Result;
use crossbeam_channel::{unbounded, Receiver, Sender};
use lofty::{probe::Probe, prelude::*};
use serde::Serialize;
use std::path::{Path, PathBuf};
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

#[derive(Debug, Clone, Serialize)]
pub struct ScanProgress {
    pub current_file: String,
    pub processed: usize,
    pub total: usize,
    pub errors: Vec<String>,
}

#[derive(Debug)]
pub enum LibraryCommand {
    Scan(Vec<String>),      // paths to scan
    RescanAll,
    GetTracks,
    SearchTracks(String),   // search query
    GetStats,
}

#[derive(Debug, Clone, Serialize)]
pub enum LibraryEvent {
    ScanStarted {
        total_paths: usize,
    },
    ScanProgress(ScanProgress),
    ScanComplete {
        tracks_added: usize,
        tracks_updated: usize,
        errors: Vec<String>,
    },
    TracksLoaded(Vec<Track>),
    SearchResults(Vec<Track>),
    LibraryStats {
        total_tracks: i64,
        total_artists: i64,
        total_albums: i64,
    },
    Error(String),
}

pub struct Library {
    db: Arc<Mutex<Database>>,
    command_rx: Receiver<LibraryCommand>,
    event_tx: Sender<LibraryEvent>,
    is_scanning: Arc<Mutex<bool>>,
}

impl Library {
    pub fn new(db: Arc<Mutex<Database>>) -> Result<(Self, Sender<LibraryCommand>, Receiver<LibraryEvent>)> {
        let (command_tx, command_rx) = unbounded();
        let (event_tx, event_rx) = unbounded();

        let library = Library {
            db,
            command_rx,
            event_tx,
            is_scanning: Arc::new(Mutex::new(false)),
        };

        Ok((library, command_tx, event_rx))
    }

    pub fn run(self) {
        thread::spawn(move || {
            log::info!("Library thread started");

            loop {
                match self.command_rx.recv() {
                    Ok(command) => {
                        if let Err(e) = self.handle_command(command) {
                            log::error!("Error handling library command: {}", e);
                            let _ = self.event_tx.send(LibraryEvent::Error(e.to_string()));
                        }
                    }
                    Err(_) => {
                        log::info!("Library command channel disconnected, stopping library thread");
                        break;
                    }
                }
            }
        });
    }

    fn handle_command(&self, command: LibraryCommand) -> Result<()> {
        match command {
            LibraryCommand::Scan(paths) => {
                self.scan_paths(paths)?;
            }
            LibraryCommand::RescanAll => {
                self.rescan_all_tracks()?;
            }
            LibraryCommand::GetTracks => {
                let tracks = self.get_all_tracks()?;
                let _ = self.event_tx.send(LibraryEvent::TracksLoaded(tracks));
            }
            LibraryCommand::SearchTracks(query) => {
                let tracks = self.search_tracks(&query)?;
                let _ = self.event_tx.send(LibraryEvent::SearchResults(tracks));
            }
            LibraryCommand::GetStats => {
                let stats = self.get_library_stats()?;
                let _ = self.event_tx.send(stats);
            }
        }
        Ok(())
    }

    fn scan_paths(&self, paths: Vec<String>) -> Result<()> {
        // Check if already scanning
        {
            let mut is_scanning = self.is_scanning.lock().unwrap();
            if *is_scanning {
                return Err(anyhow::anyhow!("Scan already in progress"));
            }
            *is_scanning = true;
        }

        log::info!("Starting library scan of {} paths", paths.len());
        let _ = self.event_tx.send(LibraryEvent::ScanStarted {
            total_paths: paths.len(),
        });

        // Collect all audio files
        let mut audio_files = Vec::new();
        let mut scan_errors = Vec::new();

        for path_str in &paths {
            let path = PathBuf::from(path_str);
            match self.collect_audio_files(&path) {
                Ok(mut files) => audio_files.append(&mut files),
                Err(e) => {
                    let error_msg = format!("Error scanning path {}: {}", path_str, e);
                    log::error!("{}", error_msg);
                    scan_errors.push(error_msg);
                }
            }
        }

        log::info!("Found {} audio files to process", audio_files.len());

        // Process files
        let mut tracks_added = 0;
        let mut tracks_updated = 0;
        let mut process_errors = Vec::new();

        for (index, file_path) in audio_files.iter().enumerate() {
            let progress = ScanProgress {
                current_file: file_path.to_string_lossy().to_string(),
                processed: index,
                total: audio_files.len(),
                errors: process_errors.clone(),
            };

            let _ = self.event_tx.send(LibraryEvent::ScanProgress(progress));

            match self.process_audio_file(file_path) {
                Ok(was_new) => {
                    if was_new {
                        tracks_added += 1;
                    } else {
                        tracks_updated += 1;
                    }
                }
                Err(e) => {
                    let error_msg = format!("Error processing {}: {}", file_path.display(), e);
                    log::error!("{}", error_msg);
                    process_errors.push(error_msg);
                }
            }

            // Small delay to prevent overwhelming the system
            thread::sleep(Duration::from_millis(1));
        }

        // Combine all errors
        scan_errors.extend(process_errors);

        // Mark scanning as complete
        {
            let mut is_scanning = self.is_scanning.lock().unwrap();
            *is_scanning = false;
        }

        let _ = self.event_tx.send(LibraryEvent::ScanComplete {
            tracks_added,
            tracks_updated,
            errors: scan_errors,
        });

        log::info!(
            "Library scan complete: {} added, {} updated",
            tracks_added,
            tracks_updated
        );

        Ok(())
    }

    fn collect_audio_files(&self, path: &Path) -> Result<Vec<PathBuf>> {
        let mut files = Vec::new();

        if path.is_file() {
            if self.is_audio_file(path) {
                files.push(path.to_path_buf());
            }
        } else if path.is_dir() {
            self.scan_directory_recursive(path, &mut files)?;
        }

        Ok(files)
    }

    fn scan_directory_recursive(&self, dir: &Path, files: &mut Vec<PathBuf>) -> Result<()> {
        for entry in std::fs::read_dir(dir)? {
            let entry = entry?;
            let path = entry.path();

            if path.is_dir() {
                // Skip hidden directories
                if let Some(name) = path.file_name() {
                    if name.to_string_lossy().starts_with('.') {
                        continue;
                    }
                }
                self.scan_directory_recursive(&path, files)?;
            } else if self.is_audio_file(&path) {
                files.push(path);
            }
        }
        Ok(())
    }

    fn is_audio_file(&self, path: &Path) -> bool {
        if let Some(extension) = path.extension() {
            let ext = extension.to_string_lossy().to_lowercase();
            // ÊîØÊåÅÁöÑÈü≥È¢ëÊ†ºÂºè - ‰∏éÊí≠ÊîæÂô®‰øùÊåÅ‰∏ÄËá¥
            matches!(
                ext.as_str(),
                // Â∏∏ËßÅÊó†ÊçüÊ†ºÂºè
                "flac" | "wav" | "aiff" | "aif" | "aifc" |
                // Â∏∏ËßÅÊúâÊçüÊ†ºÂºè  
                "mp3" | "aac" | "m4a" | "ogg" | "oga" | "opus" |
                // ÂÖ∂‰ªñÊ†ºÂºè
                "wma" | "ape" | "tak" | "tta" | "dsd" | "dsf" | "dff" |
                // Ê®°ÂùóÈü≥‰πêÊ†ºÂºè
                "mod" | "it" | "s3m" | "xm" |
                // ÂÖ∂‰ªñÊó†ÊçüÊ†ºÂºè
                "alac" | "wv" | "mka"
            )
        } else {
            false
        }
    }

    fn process_audio_file(&self, path: &Path) -> Result<bool> {
        // Check if file already exists in database
        let path_str = path.to_string_lossy().to_string();
        let db = self.db.lock().unwrap();
        let existing_track = db.get_track_by_path(&path_str)?;

        // Read metadata
        let tagged_file = Probe::open(path)?.read()?;
        let tag = tagged_file.primary_tag();
        let properties = tagged_file.properties();

        let title = tag.and_then(|t| t.title().map(|s| s.to_string()));
        let artist = tag.and_then(|t| t.artist().map(|s| s.to_string()));
        let album = tag.and_then(|t| t.album().map(|s| s.to_string()));
        let duration_ms = properties.duration().as_millis() as i64;
        
        // ÊèêÂèñ‰∏ìËæëÂ∞ÅÈù¢
        let (album_cover_data, album_cover_mime) = self.extract_album_cover(&tagged_file, tag);

        let track = Track {
            id: existing_track.as_ref().map(|t| t.id).unwrap_or(0),
            path: path_str,
            title,
            artist,
            album,
            duration_ms: Some(duration_ms),
            album_cover_data,
            album_cover_mime,
        };

        db.insert_track(&track)?;

        Ok(existing_track.is_none()) // true if new track, false if updated
    }

    fn get_all_tracks(&self) -> Result<Vec<Track>> {
        let db = self.db.lock().unwrap();
        db.get_all_tracks()
    }

    fn search_tracks(&self, query: &str) -> Result<Vec<Track>> {
        let db = self.db.lock().unwrap();
        db.search_tracks(query)
    }

    fn get_library_stats(&self) -> Result<LibraryEvent> {
        log::info!("üéµ ÂºÄÂßãËé∑ÂèñÂ∫ìÁªüËÆ°Êï∞ÊçÆ");
        let db = self.db.lock().unwrap();
        let total_tracks = db.get_track_count()?;
        let total_artists = db.get_artist_count()?;
        let total_albums = db.get_album_count()?;
        
        log::info!("üéµ ÁªüËÆ°Êï∞ÊçÆ: {} È¶ñÊ≠åÊõ≤, {} ‰ΩçËâ∫ÊúØÂÆ∂, {} Âº†‰∏ìËæë", 
                  total_tracks, total_artists, total_albums);

        Ok(LibraryEvent::LibraryStats {
            total_tracks,
            total_artists,
            total_albums,
        })
    }
    
    /// ‰ªéÈü≥È¢ëÊñá‰ª∂‰∏≠ÊèêÂèñ‰∏ìËæëÂ∞ÅÈù¢
    fn extract_album_cover(&self, tagged_file: &lofty::file::TaggedFile, tag: Option<&lofty::tag::Tag>) -> (Option<Vec<u8>>, Option<String>) {
        use lofty::picture::PictureType;
        
        // Êî∂ÈõÜÊâÄÊúâÊ†áÁ≠æÁöÑÂõæÁâá
        let mut all_pictures = Vec::new();
        
        // ‰ºòÂÖà‰ΩøÁî®‰∏ªÊ†áÁ≠æÁöÑÂõæÁâá
        if let Some(tag) = tag {
            all_pictures.extend(tag.pictures().into_iter());
        }
        
        // Â¶ÇÊûú‰∏ªÊ†áÁ≠æÊ≤°ÊúâÂõæÁâáÊàñÂõæÁâá‰∏çË∂≥ÔºåÁªßÁª≠Êî∂ÈõÜÂÖ∂‰ªñÊ†áÁ≠æ
        if all_pictures.is_empty() {
            all_pictures.extend(
                tagged_file.tags()
                    .into_iter()
                    .flat_map(|tag| tag.pictures())
            );
        }

        if all_pictures.is_empty() {
            log::warn!("‚ùå Êú™ÊâæÂà∞‰ªª‰Ωï‰∏ìËæëÂ∞ÅÈù¢");
            return (None, None);
        }

        // Êåâ‰ºòÂÖàÁ∫ßÊéíÂ∫èÔºöCoverFront > Other > IconÔºåÂêåÊó∂ËÄÉËôëÂ§ßÂ∞è
        let mut sorted_pictures = all_pictures.clone();
        sorted_pictures.sort_by(|a, b| {
            // 1. ÊåâÂõæÁâáÁ±ªÂûã‰ºòÂÖàÁ∫ßÊéíÂ∫è
            let type_priority_a = match a.pic_type() {
                PictureType::CoverFront => 0,
                PictureType::Other => 1,
                PictureType::Icon => 3,
                _ => 2,
            };
            let type_priority_b = match b.pic_type() {
                PictureType::CoverFront => 0,
                PictureType::Other => 1,
                PictureType::Icon => 3,
                _ => 2,
            };
            
            match type_priority_a.cmp(&type_priority_b) {
                std::cmp::Ordering::Equal => {
                    // 2. Á±ªÂûãÁõ∏ÂêåÊó∂ÔºåÊåâÂ§ßÂ∞èÊéíÂ∫èÔºàÂ§ßÂõæ‰ºòÂÖàÔºå‰ΩÜÊéíÈô§ËøáÂ§ßÁöÑÂõæÔºâ
                    let size_a = a.data().len();
                    let size_b = b.data().len();
                    
                    // ÊéíÈô§ËøáÂ§ßÁöÑÂõæÁâáÔºà>2MBÔºâÂíåËøáÂ∞èÁöÑÂõæÁâáÔºà<1KBÔºâ
                    let valid_a = size_a >= 1024 && size_a <= 2_097_152;
                    let valid_b = size_b >= 1024 && size_b <= 2_097_152;
                    
                    match (valid_a, valid_b) {
                        (true, false) => std::cmp::Ordering::Less,
                        (false, true) => std::cmp::Ordering::Greater,
                        (true, true) => size_b.cmp(&size_a), // Â§ßÂõæ‰ºòÂÖà
                        (false, false) => size_b.cmp(&size_a), // ÈÉΩ‰∏çÂêàÈÄÇÊó∂ËøòÊòØÊåâÂ§ßÂ∞è
                    }
                }
                other => other,
            }
        });

        if let Some(best_picture) = sorted_pictures.first() {
            let data = best_picture.data().to_vec();
            let size = data.len();
            
            // Ê£ÄÊü•ÂõæÁâáÂ§ßÂ∞èÈôêÂà∂
            if size > 3_145_728 { // 3MB
                log::warn!("‚ö†Ô∏è ‰∏ìËæëÂ∞ÅÈù¢ËøáÂ§ß ({} Â≠óËäÇ), Ë∑≥Ëøá", size);
                return (None, None);
            }
            
            if size < 512 { // 512 bytes
                log::warn!("‚ö†Ô∏è ‰∏ìËæëÂ∞ÅÈù¢ËøáÂ∞è ({} Â≠óËäÇ), Ë∑≥Ëøá", size);
                return (None, None);
            }
            
            // ÂÆΩÊùæÂ§ÑÁêÜMIMEÁ±ªÂûãÔºöÊúâÂõæÂ∞±ËøîÂõûÔºåMIME‰∏∫Á©∫Êó∂‰ΩøÁî®ÈªòËÆ§ÂÄº
            let mime_type = best_picture.mime_type()
                .map(|mime| mime.to_string())
                .or_else(|| {
                    // Ê†πÊçÆÊï∞ÊçÆÂ§¥Âà§Êñ≠ÂõæÁâáÊ†ºÂºè
                    if data.len() >= 4 {
                        if &data[0..4] == b"\xFF\xD8\xFF\xE0" || &data[0..4] == b"\xFF\xD8\xFF\xE1" {
                            Some("image/jpeg".to_string())
                        } else if &data[0..4] == b"\x89PNG" {
                            Some("image/png".to_string())
                        } else {
                            Some("image/jpeg".to_string()) // ÈªòËÆ§JPEG
                        }
                    } else {
                        Some("image/jpeg".to_string())
                    }
                });
                
            log::info!("‚úÖ ÊèêÂèñÂà∞‰∏ìËæëÂ∞ÅÈù¢: {} Â≠óËäÇ, Á±ªÂûã: {:?}, MIME: {:?}", 
                      size, best_picture.pic_type(), mime_type);
            return (Some(data), mime_type);
        }

        log::warn!("‚ùå Êú™ÊâæÂà∞ÂêàÈÄÇÁöÑ‰∏ìËæëÂ∞ÅÈù¢ - ÂÖ± {} Âº†ÂõæÁâá", all_pictures.len());
        (None, None)
    }

    /// ÈáçÊñ∞Êâ´ÊèèÊâÄÊúâÁé∞ÊúâÊõ≤ÁõÆÔºåÊõ¥Êñ∞Â∞ÅÈù¢Êï∞ÊçÆ
    fn rescan_all_tracks(&self) -> Result<()> {
        log::info!("ÂºÄÂßãÈáçÊñ∞Êâ´ÊèèÊâÄÊúâÊõ≤ÁõÆ‰ª•Êõ¥Êñ∞Â∞ÅÈù¢Êï∞ÊçÆ");
        
        // Ëé∑ÂèñÊâÄÊúâÁé∞ÊúâÊõ≤ÁõÆ
        let tracks = self.get_all_tracks()?;
        
        let _ = self.event_tx.send(LibraryEvent::ScanStarted {
            total_paths: tracks.len(),
        });

        let mut updated_count = 0;
        let mut errors = Vec::new();

        for (index, track) in tracks.iter().enumerate() {
            let progress = ScanProgress {
                current_file: track.path.clone(),
                processed: index,
                total: tracks.len(),
                errors: errors.clone(),
            };
            let _ = self.event_tx.send(LibraryEvent::ScanProgress(progress));

            // ÈáçÊñ∞Â§ÑÁêÜÈü≥È¢ëÊñá‰ª∂ÔºàËøô‰ºöÊõ¥Êñ∞Â∞ÅÈù¢Êï∞ÊçÆÔºâ
            match self.process_audio_file(Path::new(&track.path)) {
                Ok(_) => {
                    updated_count += 1;
                    log::info!("Êõ¥Êñ∞Â∞ÅÈù¢Êï∞ÊçÆ: {}", track.path);
                }
                Err(e) => {
                    let error_msg = format!("ÈáçÊñ∞Êâ´ÊèèÂ§±Ë¥• {}: {}", track.path, e);
                    log::error!("{}", error_msg);
                    errors.push(error_msg);
                }
            }
        }

        let _ = self.event_tx.send(LibraryEvent::ScanComplete {
            tracks_added: 0,
            tracks_updated: updated_count,
            errors,
        });

        log::info!("ÈáçÊñ∞Êâ´ÊèèÂÆåÊàêÔºåÊõ¥Êñ∞‰∫Ü {} ‰∏™Êõ≤ÁõÆÁöÑÂ∞ÅÈù¢Êï∞ÊçÆ", updated_count);
        Ok(())
    }
}
