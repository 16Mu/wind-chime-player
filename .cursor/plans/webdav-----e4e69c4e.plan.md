<!-- e4e69c4e-cc90-47c5-9146-7193bb17a4c9 227d6f6c-fdd1-4f09-9416-4a2edbfee187 -->
# ËøúÁ®ãÈü≥‰πêÊ∫êËá™Âä®ÂåñÂÆûÊñΩÊåáÂçó (WebDAV + FTP)

> **ü§ñ AIÊâßË°åÊåáÂçó**ÔºöÊú¨ÊñáÊ°£ËÆæËÆ°‰∏∫ÂèØË¢´AIÂÆåÊï¥Ëá™Âä®ÊâßË°å„ÄÇÊåâÁÖßÈò∂ÊÆµÈ°∫Â∫è‰æùÊ¨°ÂÆûÊñΩÔºåÊØè‰∏™Èò∂ÊÆµÂåÖÂê´ÂÆåÊï¥‰ª£Á†Å„ÄÅÈ™åËØÅÊ≠•È™§ÂíåÈîôËØØÂ§ÑÁêÜ„ÄÇÊâßË°åÊó∂‰∏•Ê†ºÈÅµÂæ™È°∫Â∫èÔºå‰∏çË∑≥Ëøá‰ªª‰ΩïÊ≠•È™§„ÄÇ

---

## üìã ÊâßË°åÂâçÁΩÆÊù°‰ª∂Ê£ÄÊü•

**AIÂøÖÈ°ªÂÖàÊâßË°å‰ª•‰∏ãÊ£ÄÊü•**Ôºö

```bash
# 1. Ê£ÄÊü•RustÂ∑•ÂÖ∑Èìæ
rustc --version  # ÈúÄË¶Å >= 1.70

# 2. Ê£ÄÊü•È°πÁõÆÁªìÊûÑ
ls src-tauri/src/webdav/  # Á°ÆËÆ§WebDAVÊ®°ÂùóÂ≠òÂú®
ls src-tauri/src/ftp/     # Á°ÆËÆ§FTPÊ®°ÂùóÂ≠òÂú®

# 3. Ê£ÄÊü•Êï∞ÊçÆÂ∫ìÊñá‰ª∂
ls src-tauri/src/db.rs    # Á°ÆËÆ§Êï∞ÊçÆÂ∫ìÊ®°ÂùóÂ≠òÂú®

# 4. Ê£ÄÊü•ÂâçÁ´ØÊ°ÜÊû∂
ls src/components/        # Á°ÆËÆ§ReactÁªÑ‰ª∂ÁõÆÂΩïÂ≠òÂú®
```

**Â¶ÇÊûú‰ªª‰ΩïÊ£ÄÊü•Â§±Ë¥•ÔºåÁ´ãÂç≥ÂÅúÊ≠¢Âπ∂Êä•ÂëäÈîôËØØ„ÄÇ**

---

## üéØ ËÆæËÆ°ÂéüÂàôÔºàÁé∞ÊúâÊû∂ÊûÑÈÅµÂæ™ÁöÑËßÑËåÉÔºâ

Âü∫‰∫é `src-tauri/src/webdav/` Ê®°ÂùóÁöÑ‰ºòÁßÄËÆæËÆ°Ôºö

1. **È´òÂÜÖËÅö‰ΩéËÄ¶Âêà** - ÊØè‰∏™Ê®°ÂùóÂçï‰∏ÄËÅåË¥£
2. **ÂÆåÂñÑÈîôËØØÂ§ÑÁêÜ** - Âå∫ÂàÜÂèØÊÅ¢Â§ç/‰∏çÂèØÊÅ¢Â§çÈîôËØØ
3. **Áä∂ÊÄÅÊú∫ËÆæËÆ°** - Èò≤Ê≠¢ÈùûÊ≥ïÁä∂ÊÄÅËΩ¨Êç¢
4. **ËµÑÊ∫êÂÆâÂÖ®ÁÆ°ÁêÜ** - ÂÜÖÂ≠òÈôêÂà∂„ÄÅË∂ÖÊó∂ÊéßÂà∂„ÄÅÁÜîÊñ≠‰øùÊä§
5. **ÂèØËßÇÊµãÊÄß** - ÂÆåÊï¥Êó•Âøó„ÄÅÁªüËÆ°„ÄÅÂÅ•Â∫∑Ê£ÄÊü•
6. **ÊµãËØïË¶ÜÁõñ** - ÊØè‰∏™Ê®°ÂùóÈÉΩÊúâÂçïÂÖÉÊµãËØï

---

## üì¶ Èò∂ÊÆµ‰∏ÄÔºö‰æùËµñÂíåÂü∫Á°ÄËÆæÊñΩ [AUTO-EXECUTE]

### Ê≠•È™§ 1.1ÔºöÊ∑ªÂä†Cargo‰æùËµñ

**Êñá‰ª∂**Ôºö`src-tauri/Cargo.toml`

**Êìç‰Ωú**ÔºöÂú® `[dependencies]` ÈÉ®ÂàÜÊ∑ªÂä†Ôºö

```toml
quick-xml = "0.31"  # WebDAV XMLËß£Êûê
```

**È™åËØÅ**ÔºöËøêË°å `cargo check`ÔºåÁ°Æ‰øùÊó†ÈîôËØØ

---

### Ê≠•È™§ 1.2ÔºöÂÆûÁé∞WebDAV XMLËß£ÊûêÂô®

**Êñ∞Âª∫Êñá‰ª∂**Ôºö`src-tauri/src/webdav/xml_parser.rs`

**ÂÆåÊï¥‰ª£Á†Å**Ôºö

```rust
// WebDAV XMLËß£ÊûêÂô® - Âçï‰∏ÄËÅåË¥£ÔºöËß£ÊûêPROPFINDÂìçÂ∫î
use super::types::*;
use quick_xml::events::Event;
use quick_xml::Reader;
use std::collections::HashMap;

/// ÊúçÂä°Âô®Á±ªÂûãÊèêÁ§∫
#[derive(Debug, Clone, PartialEq)]
pub enum ServerHints {
    Apache,
    Nginx,
    Nextcloud,
    OwnCloud,
    Synology,
    Generic,
}

/// PROPFINDÂìçÂ∫îËß£ÊûêÂô®
pub struct PropfindParser {
    server_hints: ServerHints,
}

impl PropfindParser {
    pub fn new(server_hints: ServerHints) -> Self {
        Self { server_hints }
    }

    /// Ëß£ÊûêPROPFINDÂ§öÁä∂ÊÄÅÂìçÂ∫î
    pub fn parse_multistatus(&self, xml: &str) -> WebDAVResult<Vec<WebDAVFileInfo>> {
        let mut reader = Reader::from_str(xml);
        reader.trim_text(true);
        
        let mut files = Vec::new();
        let mut buf = Vec::new();
        let mut current_response: Option<ResponseBuilder> = None;
        let mut current_prop: Option<String> = None;
        let mut text_buffer = String::new();

        loop {
            match reader.read_event_into(&mut buf) {
                Ok(Event::Start(e)) => {
                    let tag_name = String::from_utf8_lossy(e.local_name().as_ref()).to_string();
                    
                    match tag_name.as_str() {
                        "response" | "D:response" => {
                            current_response = Some(ResponseBuilder::new());
                        }
                        "href" | "D:href" => {
                            text_buffer.clear();
                        }
                        "getcontentlength" | "D:getcontentlength" => {
                            current_prop = Some("size".to_string());
                            text_buffer.clear();
                        }
                        "getcontenttype" | "D:getcontenttype" => {
                            current_prop = Some("content_type".to_string());
                            text_buffer.clear();
                        }
                        "getlastmodified" | "D:getlastmodified" => {
                            current_prop = Some("last_modified".to_string());
                            text_buffer.clear();
                        }
                        "getetag" | "D:getetag" => {
                            current_prop = Some("etag".to_string());
                            text_buffer.clear();
                        }
                        "creationdate" | "D:creationdate" => {
                            current_prop = Some("created_at".to_string());
                            text_buffer.clear();
                        }
                        "displayname" | "D:displayname" => {
                            current_prop = Some("name".to_string());
                            text_buffer.clear();
                        }
                        "collection" | "D:collection" => {
                            if let Some(ref mut resp) = current_response {
                                resp.is_directory = true;
                            }
                        }
                        _ => {}
                    }
                }
                
                Ok(Event::Text(e)) => {
                    text_buffer.push_str(&e.unescape().unwrap_or_default());
                }
                
                Ok(Event::End(e)) => {
                    let tag_name = String::from_utf8_lossy(e.local_name().as_ref()).to_string();
                    
                    match tag_name.as_str() {
                        "href" | "D:href" => {
                            if let Some(ref mut resp) = current_response {
                                resp.path = text_buffer.trim().to_string();
                            }
                        }
                        "getcontentlength" | "D:getcontentlength" |
                        "getcontenttype" | "D:getcontenttype" |
                        "getlastmodified" | "D:getlastmodified" |
                        "getetag" | "D:getetag" |
                        "creationdate" | "D:creationdate" |
                        "displayname" | "D:displayname" => {
                            if let (Some(ref mut resp), Some(ref prop)) = (&mut current_response, &current_prop) {
                                resp.set_property(prop, text_buffer.trim());
                            }
                            current_prop = None;
                        }
                        "response" | "D:response" => {
                            if let Some(builder) = current_response.take() {
                                if let Ok(file_info) = builder.build() {
                                    files.push(file_info);
                                }
                            }
                        }
                        _ => {}
                    }
                }
                
                Ok(Event::Eof) => break,
                Err(e) => {
                    log::warn!("XMLËß£ÊûêÈîôËØØ: {:?}", e);
                    break;
                }
                _ => {}
            }
            buf.clear();
        }

        log::debug!("Ëß£ÊûêÂà∞ {} ‰∏™Êñá‰ª∂/ÁõÆÂΩï", files.len());
        Ok(files)
    }

    /// Ëá™Âä®Ê£ÄÊµãÊúçÂä°Âô®Á±ªÂûã
    pub fn detect_server_type(xml: &str) -> ServerHints {
        if xml.contains("Nextcloud") || xml.contains("nextcloud") {
            ServerHints::Nextcloud
        } else if xml.contains("ownCloud") {
            ServerHints::OwnCloud
        } else if xml.contains("Apache") {
            ServerHints::Apache
        } else if xml.contains("nginx") {
            ServerHints::Nginx
        } else if xml.contains("Synology") {
            ServerHints::Synology
        } else {
            ServerHints::Generic
        }
    }
}

/// ÂìçÂ∫îÊûÑÂª∫Âô®ÔºàËæÖÂä©Á±ªÔºâ
#[derive(Debug, Default)]
struct ResponseBuilder {
    path: String,
    name: Option<String>,
    is_directory: bool,
    size: Option<u64>,
    content_type: Option<String>,
    last_modified: Option<i64>,
    etag: Option<String>,
    created_at: Option<i64>,
}

impl ResponseBuilder {
    fn new() -> Self {
        Self::default()
    }

    fn set_property(&mut self, key: &str, value: &str) {
        match key {
            "name" => self.name = Some(value.to_string()),
            "size" => self.size = value.parse().ok(),
            "content_type" => self.content_type = Some(value.to_string()),
            "last_modified" => {
                // Ëß£ÊûêHTTPÊó•ÊúüÊ†ºÂºè
                self.last_modified = parse_http_date(value);
            }
            "etag" => self.etag = Some(value.trim_matches('"').to_string()),
            "created_at" => {
                self.created_at = parse_http_date(value);
            }
            _ => {}
        }
    }

    fn build(self) -> WebDAVResult<WebDAVFileInfo> {
        let path = self.path.clone();
        let name = self.name.unwrap_or_else(|| {
            path.trim_end_matches('/').split('/').last().unwrap_or(&path).to_string()
        });

        Ok(WebDAVFileInfo {
            path,
            name,
            is_directory: self.is_directory,
            size: self.size,
            content_type: self.content_type,
            last_modified: self.last_modified,
            etag: self.etag,
            created_at: self.created_at,
        })
    }
}

/// Ëß£ÊûêHTTPÊó•ÊúüÊ†ºÂºè
fn parse_http_date(date_str: &str) -> Option<i64> {
    use chrono::DateTime;
    DateTime::parse_from_rfc2822(date_str)
        .or_else(|_| DateTime::parse_from_rfc3339(date_str))
        .ok()
        .map(|dt| dt.timestamp())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_apache_response() {
        let xml = r#"<?xml version="1.0" encoding="utf-8"?>
<D:multistatus xmlns:D="DAV:">
  <D:response>
    <D:href>/music/song.mp3</D:href>
    <D:propstat>
      <D:prop>
        <D:displayname>song.mp3</D:displayname>
        <D:getcontentlength>5242880</D:getcontentlength>
        <D:getcontenttype>audio/mpeg</D:getcontenttype>
      </D:prop>
    </D:propstat>
  </D:response>
</D:multistatus>"#;

        let parser = PropfindParser::new(ServerHints::Apache);
        let files = parser.parse_multistatus(xml).unwrap();
        
        assert_eq!(files.len(), 1);
        assert_eq!(files[0].name, "song.mp3");
        assert_eq!(files[0].size, Some(5242880));
    }
}
```

**Êõ¥Êñ∞Ê®°ÂùóÂØºÂá∫**Ôºö`src-tauri/src/webdav/mod.rs`

```rust
pub mod client;
pub mod auth;
pub mod types;
pub mod safe_stream;
pub mod resilient_client;
pub mod xml_parser;  // Êñ∞Â¢û

pub use auth::*;
pub use client::WebDAVClient;
pub use xml_parser::PropfindParser;  // Êñ∞Â¢ûÂØºÂá∫
```

**È™åËØÅ**ÔºöËøêË°å `cargo test --lib webdav::xml_parser`

---

### Ê≠•È™§ 1.3Ôºö‰øÆÂ§çWebDAVÂÆ¢Êà∑Á´ØÁöÑparse_propfind_response

**Êñá‰ª∂**Ôºö`src-tauri/src/webdav/client.rs`

**ÊõøÊç¢**ÔºöÊâæÂà∞ `parse_propfind_response` ÊñπÊ≥ïÔºàÁ∫¶Á¨¨426-439Ë°åÔºâ

```rust
// Êóß‰ª£Á†ÅÔºàÁ©∫ÂÆûÁé∞Ôºâ
fn parse_propfind_response(&self, _response_xml: &str) -> WebDAVResult<Vec<WebDAVFileInfo>> {
    let files = Vec::new();
    log::debug!("PROPFINDÂìçÂ∫îËß£ÊûêÊöÇÊú™ÂÆåÂÖ®ÂÆûÁé∞ÔºåËøîÂõûÁ©∫ÁªìÊûú");
    Ok(files)
}
```

**ÊõøÊç¢‰∏∫**Ôºö

```rust
fn parse_propfind_response(&self, response_xml: &str) -> WebDAVResult<Vec<WebDAVFileInfo>> {
    use crate::webdav::xml_parser::{PropfindParser, ServerHints};
    
    // Ëá™Âä®Ê£ÄÊµãÊúçÂä°Âô®Á±ªÂûã
    let server_hints = PropfindParser::detect_server_type(response_xml);
    log::debug!("Ê£ÄÊµãÂà∞WebDAVÊúçÂä°Âô®Á±ªÂûã: {:?}", server_hints);
    
    // ÂàõÂª∫Ëß£ÊûêÂô®Âπ∂Ëß£Êûê
    let parser = PropfindParser::new(server_hints);
    let files = parser.parse_multistatus(response_xml)?;
    
    log::debug!("ÊàêÂäüËß£Êûê {} ‰∏™Êñá‰ª∂/ÁõÆÂΩï", files.len());
    Ok(files)
}
```

**È™åËØÅ**ÔºöËøêË°å `cargo build`ÔºåÁ°Æ‰øùÁºñËØëÊàêÂäü

---

## üì¶ Èò∂ÊÆµ‰∫åÔºöÊï∞ÊçÆÂ∫ìÊû∂ÊûÑÊâ©Â±ï [AUTO-EXECUTE]

### Ê≠•È™§ 2.1ÔºöÊâ©Â±ïÊï∞ÊçÆÂ∫ìSchema

**Êñá‰ª∂**Ôºö`src-tauri/src/db.rs`

**Âú® `Database::new()` ÊñπÊ≥ïÁöÑË°®ÂàõÂª∫SQLÂêéÊ∑ªÂä†**ÔºàÊâæÂà∞Á∫¶Á¨¨200Ë°åÂ∑¶Âè≥ÔºâÔºö

```rust
// Âú®Áé∞ÊúâCREATE TABLEËØ≠Âè•ÂêéÊ∑ªÂä†Ôºö

// Áªü‰∏ÄÁöÑËøúÁ®ãÊúçÂä°Âô®ÈÖçÁΩÆË°®
conn.execute(
    "CREATE TABLE IF NOT EXISTS remote_servers (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        server_type TEXT NOT NULL,
        config_json TEXT NOT NULL,
        enabled INTEGER DEFAULT 1,
        priority INTEGER DEFAULT 0,
        created_at INTEGER NOT NULL,
        updated_at INTEGER NOT NULL,
        last_connected_at INTEGER,
        connection_status TEXT DEFAULT 'unknown'
    )",
    [],
)?;

// Áªü‰∏ÄÁöÑÁºìÂ≠òË°®
conn.execute(
    "CREATE TABLE IF NOT EXISTS remote_cache (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        server_id TEXT NOT NULL,
        remote_path TEXT NOT NULL,
        local_cache_path TEXT NOT NULL,
        file_size INTEGER,
        mime_type TEXT,
        etag TEXT,
        last_modified INTEGER,
        cached_at INTEGER NOT NULL,
        last_accessed INTEGER NOT NULL,
        access_count INTEGER DEFAULT 0,
        cache_status TEXT DEFAULT 'valid',
        UNIQUE(server_id, remote_path),
        FOREIGN KEY(server_id) REFERENCES remote_servers(id) ON DELETE CASCADE
    )",
    [],
)?;

// ÁºìÂ≠òÁ¥¢Âºï
conn.execute(
    "CREATE INDEX IF NOT EXISTS idx_cache_server ON remote_cache(server_id)",
    [],
)?;
conn.execute(
    "CREATE INDEX IF NOT EXISTS idx_cache_access ON remote_cache(last_accessed DESC)",
    [],
)?;
conn.execute(
    "CREATE INDEX IF NOT EXISTS idx_cache_status ON remote_cache(cache_status)",
    [],
)?;

// ÂêåÊ≠•‰ªªÂä°Ë°®
conn.execute(
    "CREATE TABLE IF NOT EXISTS sync_tasks (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        server_id TEXT NOT NULL,
        task_type TEXT NOT NULL,
        status TEXT DEFAULT 'pending',
        progress_current INTEGER DEFAULT 0,
        progress_total INTEGER DEFAULT 0,
        started_at INTEGER,
        completed_at INTEGER,
        error_message TEXT,
        FOREIGN KEY(server_id) REFERENCES remote_servers(id) ON DELETE CASCADE
    )",
    [],
)?;

log::info!("ËøúÁ®ãÊúçÂä°Âô®Êï∞ÊçÆÂ∫ìË°®Â∑≤ÂàõÂª∫");
```

### Ê≠•È™§ 2.2ÔºöÊ∑ªÂä†Êï∞ÊçÆÂ∫ìÊìç‰ΩúÊñπÊ≥ï

**Âú® `impl Database` ÂùóÊú´Â∞æÊ∑ªÂä†**Ôºö

```rust
// ========== ËøúÁ®ãÊúçÂä°Âô®ÁÆ°ÁêÜ ==========

pub fn add_remote_server(&self, id: &str, name: &str, server_type: &str, config_json: &str) -> Result<()> {
    let now = chrono::Utc::now().timestamp();
    self.conn.execute(
        "INSERT INTO remote_servers (id, name, server_type, config_json, created_at, updated_at) 
         VALUES (?1, ?2, ?3, ?4, ?5, ?6)",
        params![id, name, server_type, config_json, now, now],
    )?;
    log::info!("Ê∑ªÂä†ËøúÁ®ãÊúçÂä°Âô®: {} ({})", name, server_type);
    Ok(())
}

pub fn get_remote_servers(&self) -> Result<Vec<(String, String, String, String, bool)>> {
    let mut stmt = self.conn.prepare(
        "SELECT id, name, server_type, config_json, enabled FROM remote_servers ORDER BY priority DESC, name ASC"
    )?;
    
    let servers = stmt.query_map([], |row| {
        Ok((
            row.get(0)?,
            row.get(1)?,
            row.get(2)?,
            row.get(3)?,
            row.get::<_, i64>(4)? == 1,
        ))
    })?
    .collect::<Result<Vec<_>, _>>()?;
    
    Ok(servers)
}

pub fn delete_remote_server(&self, id: &str) -> Result<()> {
    self.conn.execute("DELETE FROM remote_servers WHERE id = ?1", params![id])?;
    log::info!("Âà†Èô§ËøúÁ®ãÊúçÂä°Âô®: {}", id);
    Ok(())
}

// ========== ÁºìÂ≠òÁÆ°ÁêÜ ==========

pub fn add_cache_entry(
    &self,
    server_id: &str,
    remote_path: &str,
    local_cache_path: &str,
    file_size: Option<i64>,
    mime_type: Option<&str>,
) -> Result<i64> {
    let now = chrono::Utc::now().timestamp();
    
    self.conn.execute(
        "INSERT OR REPLACE INTO remote_cache 
         (server_id, remote_path, local_cache_path, file_size, mime_type, cached_at, last_accessed, access_count)
         VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, 1)",
        params![server_id, remote_path, local_cache_path, file_size, mime_type, now, now],
    )?;
    
    Ok(self.conn.last_insert_rowid())
}

pub fn get_cache_entry(&self, server_id: &str, remote_path: &str) -> Result<Option<String>> {
    let mut stmt = self.conn.prepare(
        "SELECT local_cache_path FROM remote_cache 
         WHERE server_id = ?1 AND remote_path = ?2 AND cache_status = 'valid'"
    )?;
    
    let result = stmt.query_row(params![server_id, remote_path], |row| row.get(0))
        .optional()?;
    
    // Êõ¥Êñ∞ËÆøÈóÆÊó∂Èó¥
    if result.is_some() {
        let now = chrono::Utc::now().timestamp();
        self.conn.execute(
            "UPDATE remote_cache SET last_accessed = ?1, access_count = access_count + 1 
             WHERE server_id = ?2 AND remote_path = ?3",
            params![now, server_id, remote_path],
        )?;
    }
    
    Ok(result)
}

pub fn get_cache_stats(&self) -> Result<(i64, i64)> {
    let mut stmt = self.conn.prepare(
        "SELECT COUNT(*), COALESCE(SUM(file_size), 0) FROM remote_cache WHERE cache_status = 'valid'"
    )?;
    
    stmt.query_row([], |row| Ok((row.get(0)?, row.get(1)?)))
}
```

**È™åËØÅ**ÔºöËøêË°å `cargo build`

---

## üì¶ Èò∂ÊÆµ‰∏âÔºöÁªü‰∏ÄËøúÁ®ãÊ∫êÊäΩË±°Â±Ç [AUTO-EXECUTE]

### Ê≠•È™§ 3.1ÔºöÂàõÂª∫ËøúÁ®ãÊ∫êÊ®°Âùó

**Êñ∞Âª∫ÁõÆÂΩï**Ôºö`src-tauri/src/remote_source/`

**Êñ∞Âª∫Êñá‰ª∂**Ôºö`src-tauri/src/remote_source/mod.rs`

```rust
// ËøúÁ®ãÈü≥‰πêÊ∫êÁªü‰∏ÄÊäΩË±°Â±Ç
pub mod types;

pub use types::*;
```

**Êñ∞Âª∫Êñá‰ª∂**Ôºö`src-tauri/src/remote_source/types.rs`

```rust
use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use tokio::io::AsyncRead;
use anyhow::Result;

/// ËøúÁ®ãÊ∫êÁ±ªÂûã
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum RemoteSourceType {
    WebDAV,
    FTP,
}

impl std::fmt::Display for RemoteSourceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            RemoteSourceType::WebDAV => write!(f, "webdav"),
            RemoteSourceType::FTP => write!(f, "ftp"),
        }
    }
}

/// Áªü‰∏ÄÁöÑËøúÁ®ãÊñá‰ª∂‰ø°ÊÅØ
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RemoteFileInfo {
    pub path: String,
    pub name: String,
    pub is_directory: bool,
    pub size: Option<u64>,
    pub mime_type: Option<String>,
    pub last_modified: Option<i64>,
    pub etag: Option<String>,
    pub source_type: RemoteSourceType,
}

/// ËøûÊé•Áä∂ÊÄÅ
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ConnectionStatus {
    Unknown,
    Connecting,
    Connected,
    Disconnected,
    Error(String),
}

/// ÂÅ•Â∫∑Áä∂ÊÄÅ
#[derive(Debug, Clone, Serialize)]
pub struct HealthStatus {
    pub is_healthy: bool,
    pub last_check: i64,
    pub error_count: u32,
    pub connection_status: ConnectionStatus,
}

/// ËøúÁ®ãÊ∫êÂÆ¢Êà∑Á´ØÁªü‰∏ÄÊé•Âè£
#[async_trait]
pub trait RemoteSourceClient: Send + Sync {
    /// ÊµãËØïËøûÊé•
    async fn test_connection(&self) -> Result<ConnectionStatus>;
    
    /// ÂàóÂá∫ÁõÆÂΩï
    async fn list_directory(&self, path: &str) -> Result<Vec<RemoteFileInfo>>;
    
    /// Ëé∑ÂèñÊñá‰ª∂‰ø°ÊÅØ
    async fn get_file_info(&self, path: &str) -> Result<RemoteFileInfo>;
    
    /// ‰∏ãËΩΩÊñá‰ª∂ÊµÅ
    async fn download_stream(&self, path: &str) -> Result<Box<dyn AsyncRead + Send + Unpin>>;
    
    /// ËåÉÂõ¥‰∏ãËΩΩ
    async fn download_range(&self, path: &str, start: u64, end: Option<u64>) 
        -> Result<Box<dyn AsyncRead + Send + Unpin>>;
    
    /// Ëé∑ÂèñÂÅ•Â∫∑Áä∂ÊÄÅ
    fn get_health(&self) -> HealthStatus;
    
    /// Ëé∑ÂèñÊ∫êÁ±ªÂûã
    fn get_source_type(&self) -> RemoteSourceType;
}
```

**Êõ¥Êñ∞ `src-tauri/src/lib.rs`**ÔºöÂú®Ê®°ÂùóÂ£∞ÊòéÂ§ÑÊ∑ªÂä†

```rust
mod remote_source; // Êñ∞Â¢û
```

**È™åËØÅ**ÔºöËøêË°å `cargo build`

---

## üì¶ Èò∂ÊÆµÂõõÔºöÂÆûÁé∞WebDAVÈÄÇÈÖçÂô® [AUTO-EXECUTE]

### Ê≠•È™§ 4.1Ôºö‰∏∫WebDAVÂÆûÁé∞RemoteSourceClient

**Êñ∞Âª∫Êñá‰ª∂**Ôºö`src-tauri/src/webdav/remote_adapter.rs`

```rust
// WebDAVËøúÁ®ãÊ∫êÈÄÇÈÖçÂô® - ÂÆûÁé∞RemoteSourceClient trait
use super::{WebDAVClient, types::*};
use crate::remote_source::{RemoteSourceClient, RemoteFileInfo, RemoteSourceType, ConnectionStatus, HealthStatus};
use async_trait::async_trait;
use anyhow::Result;
use tokio::io::AsyncRead;

/// WebDAVËøúÁ®ãÊ∫êÈÄÇÈÖçÂô®
pub struct WebDAVRemoteAdapter {
    client: WebDAVClient,
}

impl WebDAVRemoteAdapter {
    pub fn new(client: WebDAVClient) -> Self {
        Self { client }
    }
}

#[async_trait]
impl RemoteSourceClient for WebDAVRemoteAdapter {
    async fn test_connection(&self) -> Result<ConnectionStatus> {
        match self.client.test_connection().await {
            Ok(_) => Ok(ConnectionStatus::Connected),
            Err(e) => Ok(ConnectionStatus::Error(e.to_string())),
        }
    }

    async fn list_directory(&self, path: &str) -> Result<Vec<RemoteFileInfo>> {
        let listing = self.client.list_directory(path).await?;
        
        Ok(listing.files.into_iter().map(|f| RemoteFileInfo {
            path: f.path,
            name: f.name,
            is_directory: f.is_directory,
            size: f.size,
            mime_type: f.content_type,
            last_modified: f.last_modified,
            etag: f.etag,
            source_type: RemoteSourceType::WebDAV,
        }).collect())
    }

    async fn get_file_info(&self, path: &str) -> Result<RemoteFileInfo> {
        let info = self.client.get_file_info(path).await?;
        
        Ok(RemoteFileInfo {
            path: info.path,
            name: info.name,
            is_directory: info.is_directory,
            size: info.size,
            mime_type: info.content_type,
            last_modified: info.last_modified,
            etag: info.etag,
            source_type: RemoteSourceType::WebDAV,
        })
    }

    async fn download_stream(&self, path: &str) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
        let stream = self.client.download_stream(path).await?;
        
        use crate::webdav::safe_stream::{SafeWebDAVStream, SafeStreamConfig};
        let safe_stream = SafeWebDAVStream::from_webdav_stream(stream, SafeStreamConfig::default());
        
        Ok(Box::new(safe_stream))
    }

    async fn download_range(&self, path: &str, start: u64, end: Option<u64>) 
        -> Result<Box<dyn AsyncRead + Send + Unpin>> {
        let range = RangeRequest { start, end };
        let stream = self.client.download_range(path, range).await?;
        
        use crate::webdav::safe_stream::{SafeWebDAVStream, SafeStreamConfig};
        let safe_stream = SafeWebDAVStream::from_webdav_stream(stream, SafeStreamConfig::default());
        
        Ok(Box::new(safe_stream))
    }

    fn get_health(&self) -> HealthStatus {
        HealthStatus {
            is_healthy: true,
            last_check: chrono::Utc::now().timestamp(),
            error_count: 0,
            connection_status: ConnectionStatus::Connected,
        }
    }

    fn get_source_type(&self) -> RemoteSourceType {
        RemoteSourceType::WebDAV
    }
}
```

**Êõ¥Êñ∞ `src-tauri/src/webdav/mod.rs`**Ôºö

```rust
pub mod remote_adapter;  // Êñ∞Â¢û
pub use remote_adapter::WebDAVRemoteAdapter;  // Êñ∞Â¢ûÂØºÂá∫
```

**È™åËØÅ**ÔºöËøêË°å `cargo build`

---

## üì¶ Èò∂ÊÆµ‰∫îÔºöTauriÂëΩ‰ª§Êâ©Â±ï [AUTO-EXECUTE]

### Ê≠•È™§ 5.1ÔºöÊ∑ªÂä†ËøúÁ®ãÊúçÂä°Âô®ÁÆ°ÁêÜÂëΩ‰ª§

**Êñá‰ª∂**Ôºö`src-tauri/src/lib.rs`

**Âú®Áé∞ÊúâÂëΩ‰ª§ÂêéÊ∑ªÂä†**ÔºàÁ∫¶Á¨¨835Ë°å‰πãÂêéÔºâÔºö

```rust
// ============================================================
// ËøúÁ®ãÈü≥‰πêÊ∫êÂëΩ‰ª§ (Áªü‰∏ÄWebDAVÂíåFTP)
// ============================================================

#[tauri::command]
async fn remote_add_server(
    db: State<'_, Arc<Mutex<Database>>>,
    server_type: String,
    name: String,
    config_json: String,
) -> Result<String, String> {
    let id = format!("{}_{}", server_type, uuid::Uuid::new_v4().to_string());
    
    db.lock().unwrap()
        .add_remote_server(&id, &name, &server_type, &config_json)
        .map_err(|e| e.to_string())?;
    
    log::info!("Ê∑ªÂä†ËøúÁ®ãÊúçÂä°Âô®: {} ({})", name, server_type);
    Ok(id)
}

#[tauri::command]
async fn remote_get_servers(
    db: State<'_, Arc<Mutex<Database>>>,
) -> Result<Vec<serde_json::Value>, String> {
    let servers = db.lock().unwrap()
        .get_remote_servers()
        .map_err(|e| e.to_string())?;
    
    let result: Vec<serde_json::Value> = servers.into_iter()
        .map(|(id, name, server_type, config_json, enabled)| {
            serde_json::json!({
                "id": id,
                "name": name,
                "server_type": server_type,
                "config": serde_json::from_str::<serde_json::Value>(&config_json).unwrap_or(serde_json::json!({})),
                "enabled": enabled
            })
        })
        .collect();
    
    Ok(result)
}

#[tauri::command]
async fn remote_delete_server(
    db: State<'_, Arc<Mutex<Database>>>,
    server_id: String,
) -> Result<(), String> {
    db.lock().unwrap()
        .delete_remote_server(&server_id)
        .map_err(|e| e.to_string())?;
    
    log::info!("Âà†Èô§ËøúÁ®ãÊúçÂä°Âô®: {}", server_id);
    Ok(())
}

#[tauri::command]
async fn remote_get_cache_stats(
    db: State<'_, Arc<Mutex<Database>>>,
) -> Result<serde_json::Value, String> {
    let (count, total_size) = db.lock().unwrap()
        .get_cache_stats()
        .map_err(|e| e.to_string())?;
    
    Ok(serde_json::json!({
        "file_count": count,
        "total_size_mb": total_size / (1024 * 1024),
    }))
}
```

### Ê≠•È™§ 5.2ÔºöÊ≥®ÂÜåÊñ∞ÂëΩ‰ª§

**Âú® `invoke_handler` ‰∏≠Ê∑ªÂä†**ÔºàÁ∫¶Á¨¨1348Ë°åÔºâÔºö

```rust
.invoke_handler(tauri::generate_handler![
    // ... Áé∞ÊúâÂëΩ‰ª§ ...
    
    // ËøúÁ®ãÈü≥‰πêÊ∫êÂëΩ‰ª§ (Êñ∞Â¢û)
    remote_add_server,
    remote_get_servers,
    remote_delete_server,
    remote_get_cache_stats,
])
```

**Ê∑ªÂä†uuid‰æùËµñ**Ôºö`src-tauri/Cargo.toml`

```toml
uuid = { version = "1.6", features = ["v4"] }
```

**È™åËØÅ**ÔºöËøêË°å `cargo build`

---

## üì¶ Èò∂ÊÆµÂÖ≠ÔºöÂâçÁ´ØUIÂÆûÁé∞ [AUTO-EXECUTE]

### Ê≠•È™§ 6.1ÔºöÂàõÂª∫Áªü‰∏ÄËøúÁ®ãÊ∫êËÆæÁΩÆÈ°µÈù¢

**ÊõøÊç¢Êñá‰ª∂**Ôºö`src/components/settings/WebDAVSettings.tsx`

```typescript
import { useState, useEffect } from 'react';
import { invoke } from '@tauri-apps/api/core';

interface RemoteServer {
  id: string;
  name: string;
  server_type: 'webdav' | 'ftp';
  config: any;
  enabled: boolean;
}

interface CacheStats {
  file_count: number;
  total_size_mb: number;
}

export default function WebDAVSettings() {
  const [servers, setServers] = useState<RemoteServer[]>([]);
  const [cacheStats, setCacheStats] = useState<CacheStats | null>(null);
  const [showAddDialog, setShowAddDialog] = useState(false);
  const [activeTab, setActiveTab] = useState<'webdav' | 'ftp'>('webdav');

  useEffect(() => {
    loadServers();
    loadCacheStats();
  }, []);

  const loadServers = async () => {
    try {
      const data = await invoke<RemoteServer[]>('remote_get_servers');
      setServers(data);
    } catch (error) {
      console.error('Âä†ËΩΩÊúçÂä°Âô®ÂàóË°®Â§±Ë¥•:', error);
    }
  };

  const loadCacheStats = async () => {
    try {
      const stats = await invoke<CacheStats>('remote_get_cache_stats');
      setCacheStats(stats);
    } catch (error) {
      console.error('Âä†ËΩΩÁºìÂ≠òÁªüËÆ°Â§±Ë¥•:', error);
    }
  };

  const handleAddServer = async (type: 'webdav' | 'ftp', config: any) => {
    try {
      const configJson = JSON.stringify(config);
      await invoke('remote_add_server', {
        serverType: type,
        name: config.name,
        configJson,
      });
      loadServers();
      setShowAddDialog(false);
    } catch (error) {
      console.error('Ê∑ªÂä†ÊúçÂä°Âô®Â§±Ë¥•:', error);
      alert(`Ê∑ªÂä†Â§±Ë¥•: ${error}`);
    }
  };

  const handleDelete = async (serverId: string) => {
    if (!confirm('Á°ÆÂÆöË¶ÅÂà†Èô§Ê≠§ÊúçÂä°Âô®ÂêóÔºü')) return;
    
    try {
      await invoke('remote_delete_server', { serverId });
      loadServers();
    } catch (error) {
      console.error('Âà†Èô§ÊúçÂä°Âô®Â§±Ë¥•:', error);
    }
  };

  const webdavServers = servers.filter(s => s.server_type === 'webdav');
  const ftpServers = servers.filter(s => s.server_type === 'ftp');

  return (
    <div className="space-y-6">
      <div>
        <h2 className="text-2xl font-bold text-slate-900 dark:text-dark-900 mb-2">
          ËøúÁ®ãÈü≥‰πêÊ∫ê
        </h2>
        <p className="text-slate-600 dark:text-dark-700">
          ÈÄöËøá WebDAV / FTP ËÆøÈóÆËøúÁ®ãÈü≥‰πêÂ∫ì
        </p>
      </div>

      {/* TabÂàáÊç¢ */}
      <div className="flex space-x-1 bg-slate-100 dark:bg-dark-300 p-1 rounded-lg">
        <button
          onClick={() => setActiveTab('webdav')}
          className={`flex-1 px-4 py-2 rounded-md font-medium transition-colors ${
            activeTab === 'webdav'
              ? 'bg-white dark:bg-dark-200 text-blue-600 dark:text-blue-400 shadow-sm'
              : 'text-slate-600 dark:text-dark-700 hover:text-slate-900 dark:hover:text-dark-900'
          }`}
        >
          WebDAV ({webdavServers.length})
        </button>
        <button
          onClick={() => setActiveTab('ftp')}
          className={`flex-1 px-4 py-2 rounded-md font-medium transition-colors ${
            activeTab === 'ftp'
              ? 'bg-white dark:bg-dark-200 text-blue-600 dark:text-blue-400 shadow-sm'
              : 'text-slate-600 dark:text-dark-700 hover:text-slate-900 dark:hover:text-dark-900'
          }`}
        >
          FTP ({ftpServers.length})
        </button>
      </div>

      {/* ÁºìÂ≠òÁªüËÆ° */}
      {cacheStats && (
        <div className="bg-blue-50 dark:bg-blue-900/20 rounded-xl p-4 border border-blue-200 dark:border-blue-800">
          <div className="flex items-center justify-between">
            <div>
              <h3 className="font-medium text-slate-900 dark:text-dark-900">ÁºìÂ≠òÁªüËÆ°</h3>
              <p className="text-sm text-slate-600 dark:text-dark-700 mt-1">
                Â∑≤ÁºìÂ≠ò {cacheStats.file_count} ‰∏™Êñá‰ª∂ÔºåÂÖ± {cacheStats.total_size_mb} MB
              </p>
            </div>
            <button className="px-4 py-2 text-sm font-medium text-blue-600 dark:text-blue-400 hover:bg-blue-100 dark:hover:bg-blue-900/30 rounded-lg transition-colors">
              Ê∏ÖÁêÜÁºìÂ≠ò
            </button>
          </div>
        </div>
      )}

      {/* ÊúçÂä°Âô®ÂàóË°® */}
      <div className="space-y-3">
        {(activeTab === 'webdav' ? webdavServers : ftpServers).length === 0 ? (
          <div className="text-center py-12 bg-slate-50 dark:bg-dark-300 rounded-xl">
            <p className="text-slate-500 dark:text-dark-700">
              ËøòÊ≤°ÊúâÊ∑ªÂä†{activeTab === 'webdav' ? 'WebDAV' : 'FTP'}ÊúçÂä°Âô®
            </p>
          </div>
        ) : (
          (activeTab === 'webdav' ? webdavServers : ftpServers).map(server => (
            <div
              key={server.id}
              className="bg-white dark:bg-dark-200 rounded-xl p-4 border border-slate-200 dark:border-dark-400"
            >
              <div className="flex items-center justify-between">
                <div className="flex-1">
                  <h3 className="font-medium text-slate-900 dark:text-dark-900">{server.name}</h3>
                  <p className="text-sm text-slate-600 dark:text-dark-700 mt-1">
                    {server.config.url || server.config.host}
                  </p>
                </div>
                <div className="flex items-center space-x-2">
                  <span className="px-2 py-1 text-xs font-medium rounded bg-green-100 dark:bg-green-900/30 text-green-700 dark:text-green-400">
                    Â∑≤ËøûÊé•
                  </span>
                  <button
                    onClick={() => handleDelete(server.id)}
                    className="p-2 text-slate-400 hover:text-red-600 dark:hover:text-red-400 transition-colors"
                  >
                    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                    </svg>
                  </button>
                </div>
              </div>
            </div>
          ))
        )}
      </div>

      {/* Ê∑ªÂä†ÊåâÈíÆ */}
      <button
        onClick={() => setShowAddDialog(true)}
        className="w-full py-3 bg-blue-600 hover:bg-blue-700 dark:bg-blue-500 dark:hover:bg-blue-600 text-white font-medium rounded-xl transition-colors"
      >
        + Ê∑ªÂä†{activeTab === 'webdav' ? 'WebDAV' : 'FTP'}ÊúçÂä°Âô®
      </button>

      {/* Ê∑ªÂä†ÂØπËØùÊ°ÜÔºàÁÆÄÂåñÁâàÔºâ */}
      {showAddDialog && (
        <AddServerDialog
          type={activeTab}
          onAdd={handleAddServer}
          onClose={() => setShowAddDialog(false)}
        />
      )}
    </div>
  );
}

// Ê∑ªÂä†ÊúçÂä°Âô®ÂØπËØùÊ°ÜÁªÑ‰ª∂
function AddServerDialog({ type, onAdd, onClose }: any) {
  const [config, setConfig] = useState({
    name: '',
    url: type === 'webdav' ? '' : undefined,
    host: type === 'ftp' ? '' : undefined,
    port: type === 'ftp' ? 21 : undefined,
    username: '',
    password: '',
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    onAdd(type, config);
  };

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div className="bg-white dark:bg-dark-200 rounded-2xl p-6 max-w-md w-full mx-4">
        <h3 className="text-xl font-bold text-slate-900 dark:text-dark-900 mb-4">
          Ê∑ªÂä†{type === 'webdav' ? 'WebDAV' : 'FTP'}ÊúçÂä°Âô®
        </h3>
        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label className="block text-sm font-medium text-slate-700 dark:text-dark-800 mb-1">
              ÊúçÂä°Âô®ÂêçÁß∞
            </label>
            <input
              type="text"
              value={config.name}
              onChange={e => setConfig({ ...config, name: e.target.value })}
              className="w-full px-3 py-2 rounded-lg border border-slate-300 dark:border-dark-400 bg-white dark:bg-dark-300 text-slate-900 dark:text-dark-900"
              required
            />
          </div>
          
          {type === 'webdav' ? (
            <div>
              <label className="block text-sm font-medium text-slate-700 dark:text-dark-800 mb-1">
                WebDAV URL
              </label>
              <input
                type="url"
                value={config.url}
                onChange={e => setConfig({ ...config, url: e.target.value })}
                placeholder="https://example.com/webdav"
                className="w-full px-3 py-2 rounded-lg border border-slate-300 dark:border-dark-400 bg-white dark:bg-dark-300 text-slate-900 dark:text-dark-900"
                required
              />
            </div>
          ) : (
            <div className="grid grid-cols-2 gap-3">
              <div>
                <label className="block text-sm font-medium text-slate-700 dark:text-dark-800 mb-1">
                  ‰∏ªÊú∫Âú∞ÂùÄ
                </label>
                <input
                  type="text"
                  value={config.host}
                  onChange={e => setConfig({ ...config, host: e.target.value })}
                  placeholder="ftp.example.com"
                  className="w-full px-3 py-2 rounded-lg border border-slate-300 dark:border-dark-400 bg-white dark:bg-dark-300 text-slate-900 dark:text-dark-900"
                  required
                />
              </div>
              <div>
                <label className="block text-sm font-medium text-slate-700 dark:text-dark-800 mb-1">
                  Á´ØÂè£
                </label>
                <input
                  type="number"
                  value={config.port}
                  onChange={e => setConfig({ ...config, port: parseInt(e.target.value) })}
                  className="w-full px-3 py-2 rounded-lg border border-slate-300 dark:border-dark-400 bg-white dark:bg-dark-300 text-slate-900 dark:text-dark-900"
                  required
                />
              </div>
            </div>
          )}

          <div>
            <label className="block text-sm font-medium text-slate-700 dark:text-dark-800 mb-1">
              Áî®Êà∑Âêç
            </label>
            <input
              type="text"
              value={config.username}
              onChange={e => setConfig({ ...config, username: e.target.value })}
              className="w-full px-3 py-2 rounded-lg border border-slate-300 dark:border-dark-400 bg-white dark:bg-dark-300 text-slate-900 dark:text-dark-900"
              required
            />
          </div>

          <div>
            <label className="block text-sm font-medium text-slate-700 dark:text-dark-800 mb-1">
              ÂØÜÁ†Å
            </label>
            <input
              type="password"
              value={config.password}
              onChange={e => setConfig({ ...config, password: e.target.value })}
              className="w-full px-3 py-2 rounded-lg border border-slate-300 dark:border-dark-400 bg-white dark:bg-dark-300 text-slate-900 dark:text-dark-900"
              required
            />
          </div>

          <div className="flex space-x-3 pt-2">
            <button
              type="button"
              onClick={onClose}
              className="flex-1 px-4 py-2 border border-slate-300 dark:border-dark-400 text-slate-700 dark:text-dark-800 font-medium rounded-lg hover:bg-slate-50 dark:hover:bg-dark-300 transition-colors"
            >
              ÂèñÊ∂à
            </button>
            <button
              type="submit"
              className="flex-1 px-4 py-2 bg-blue-600 hover:bg-blue-700 dark:bg-blue-500 dark:hover:bg-blue-600 text-white font-medium rounded-lg transition-colors"
            >
              Ê∑ªÂä†
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}
```

**È™åËØÅ**ÔºöÂêØÂä®Â∫îÁî®ÔºåÊ£ÄÊü•UIÊòØÂê¶Ê≠£Â∏∏ÊòæÁ§∫

---

## üì¶ Èò∂ÊÆµ‰∏ÉÔºöËá™Âä®ÂåñÊµãËØï‰∏éÈ™åËØÅ [AUTO-EXECUTE]

### Ê≠•È™§ 7.1ÔºöËøêË°åÁºñËØëÊµãËØï

```bash
cd src-tauri
cargo build --release
```

**È¢ÑÊúü**ÔºöÁºñËØëÊàêÂäüÔºåÊó†ÈîôËØØ

### Ê≠•È™§ 7.2ÔºöËøêË°åÂçïÂÖÉÊµãËØï

```bash
cargo test
```

**È¢ÑÊúü**ÔºöÊâÄÊúâÊµãËØïÈÄöËøá

### Ê≠•È™§ 7.3ÔºöÂêØÂä®Â∫îÁî®È™åËØÅ

```bash
npm run tauri dev
```

**È™åËØÅÊ∏ÖÂçï**Ôºö

- [ ] Â∫îÁî®Ê≠£Â∏∏ÂêØÂä®
- [ ] ËÆæÁΩÆÈ°µÈù¢ÊòæÁ§∫"ËøúÁ®ãÈü≥‰πêÊ∫ê"
- [ ] ÂèØ‰ª•ÂàáÊç¢WebDAV/FTPÊ†áÁ≠æ
- [ ] ÂèØ‰ª•ÊâìÂºÄÊ∑ªÂä†ÊúçÂä°Âô®ÂØπËØùÊ°Ü
- [ ] Ë°®ÂçïËæìÂÖ•Ê≠£Â∏∏
- [ ] ÁºìÂ≠òÁªüËÆ°ÊòæÁ§∫Ê≠£Â∏∏

---

## ‚úÖ ÂÆåÊàêÊ†áÂøó

ÂΩì‰ª•‰∏äÊâÄÊúâÊ≠•È™§ÊâßË°åÂÆåÊàê‰∏îÈ™åËØÅÈÄöËøáÂêéÔºå**ËøúÁ®ãÈü≥‰πêÊ∫êÂü∫Á°ÄÊû∂ÊûÑÂ∑≤ÊàêÂäüÂÆûÁé∞**„ÄÇ

### Â∑≤ÂÆåÊàêÂäüËÉΩ

- ‚úÖ WebDAV XMLËß£ÊûêÂô®ÔºàÊîØÊåÅÂ§öÁßçÊúçÂä°Âô®Ôºâ
- ‚úÖ Êï∞ÊçÆÂ∫ìÊû∂ÊûÑÊâ©Â±ïÔºàÊúçÂä°Âô®„ÄÅÁºìÂ≠ò„ÄÅ‰ªªÂä°Ë°®Ôºâ
- ‚úÖ Áªü‰∏ÄËøúÁ®ãÊ∫êÊäΩË±°Â±Ç
- ‚úÖ WebDAVËøúÁ®ãÊ∫êÈÄÇÈÖçÂô®
- ‚úÖ TauriÂëΩ‰ª§API
- ‚úÖ ÂâçÁ´ØËÆæÁΩÆUIÔºàWebDAV/FTPÁªü‰∏ÄÁïåÈù¢Ôºâ
- ‚úÖ ÁºìÂ≠òÁªüËÆ°ÂäüËÉΩ

### ÂêéÁª≠Êâ©Â±ïÊñπÂêëÔºàÂèØÈÄâÔºâ

1. **Êô∫ËÉΩÁºìÂ≠òÁÆ°ÁêÜÂô®** - Ëá™Âä®ÁºìÂ≠òÁ≠ñÁï•„ÄÅLRUÊ∑òÊ±∞
2. **ËøúÁ®ãÈü≥‰πêÊâ´ÊèèÂô®** - ÈÄíÂΩíÊâ´Êèè„ÄÅÂÖÉÊï∞ÊçÆÊèêÂèñ
3. **Êí≠ÊîæÂô®ÈõÜÊàê** - ÁºìÂ≠òÊ£ÄÊü•„ÄÅÊµÅÂºèÊí≠Êîæ
4. **FTPÊ®°ÂùóÂ¢ûÂº∫** - ÂØπÈΩêWebDAVÁöÑÂºπÊÄßËÆæËÆ°
5. **Êñá‰ª∂ÊµèËßàÂô®ÁªÑ‰ª∂** - ËôöÊãüÊªöÂä®„ÄÅÈù¢ÂåÖÂ±ëÂØºËà™

---

## üö® ÊïÖÈöúÊéíÊü•ÊåáÂçó

### ÈóÆÈ¢ò1ÔºöÁºñËØëÂ§±Ë¥• - Êâæ‰∏çÂà∞Ê®°Âùó

**Ëß£ÂÜ≥**ÔºöÊ£ÄÊü• `mod.rs` Êñá‰ª∂ÊòØÂê¶Ê≠£Á°ÆÂØºÂá∫ÔºåËøêË°åÔºö

```bash
grep -r "pub mod" src-tauri/src/
```

### ÈóÆÈ¢ò2ÔºöXMLËß£ÊûêËøîÂõûÁ©∫ÁªìÊûú

**Ëß£ÂÜ≥**ÔºöÊ∑ªÂä†Ë∞ÉËØïÊó•ÂøóÔºö

```rust
log::debug!("XMLÂìçÂ∫î: {}", response_xml);
```

Ê£ÄÊü•XMLÊ†ºÂºèÊòØÂê¶Á¨¶ÂêàÈ¢ÑÊúü

### ÈóÆÈ¢ò3ÔºöÊï∞ÊçÆÂ∫ìÊìç‰ΩúÂ§±Ë¥•

**Ëß£ÂÜ≥**ÔºöÊ£ÄÊü•Ë°®ÊòØÂê¶ÂàõÂª∫ÊàêÂäüÔºö

```rust
// Âú®Database::new()ÂêéÊ∑ªÂä†
conn.execute("SELECT name FROM sqlite_master WHERE type='table'", [])
```

### ÈóÆÈ¢ò4ÔºöÂâçÁ´ØÊó†Ê≥ïË∞ÉÁî®ÂëΩ‰ª§

**Ëß£ÂÜ≥**ÔºöÁ°ÆËÆ§ÂëΩ‰ª§Â∑≤Ê≥®ÂÜåÂà∞ `invoke_handler![]` ‰∏≠

---

## üìù AIÊâßË°åÂÆåÊàêÊä•ÂëäÊ®°Êùø

ÊâßË°åÂÆåÊàêÂêéÔºåAIÂ∫îÁîüÊàêÂ¶Ç‰∏ãÊä•ÂëäÔºö

```
‚úÖ ËøúÁ®ãÈü≥‰πêÊ∫êÂÆûÊñΩÂÆåÊàêÊä•Âëä

Èò∂ÊÆµ‰∏ÄÔºö‰æùËµñÂíåÂü∫Á°ÄËÆæÊñΩ
- ‚úÖ Ê∑ªÂä†quick-xml‰æùËµñ
- ‚úÖ ÂÆûÁé∞XMLËß£ÊûêÂô® (src-tauri/src/webdav/xml_parser.rs)
- ‚úÖ ‰øÆÂ§çparse_propfind_responseÊñπÊ≥ï

Èò∂ÊÆµ‰∫åÔºöÊï∞ÊçÆÂ∫ìÊû∂ÊûÑÊâ©Â±ï
- ‚úÖ Ê∑ªÂä†remote_serversË°®
- ‚úÖ Ê∑ªÂä†remote_cacheË°®
- ‚úÖ Ê∑ªÂä†sync_tasksË°®
- ‚úÖ ÂÆûÁé∞Êï∞ÊçÆÂ∫ìÊìç‰ΩúÊñπÊ≥ï

Èò∂ÊÆµ‰∏âÔºöÁªü‰∏ÄËøúÁ®ãÊ∫êÊäΩË±°Â±Ç
- ‚úÖ ÂàõÂª∫remote_sourceÊ®°Âùó
- ‚úÖ ÂÆö‰πâRemoteSourceClient trait
- ‚úÖ ÂÆö‰πâÁªü‰∏ÄÁ±ªÂûã

Èò∂ÊÆµÂõõÔºöWebDAVÈÄÇÈÖçÂô®
- ‚úÖ ÂÆûÁé∞WebDAVRemoteAdapter

Èò∂ÊÆµ‰∫îÔºöTauriÂëΩ‰ª§Êâ©Â±ï
- ‚úÖ Ê∑ªÂä†remote_add_serverÂëΩ‰ª§
- ‚úÖ Ê∑ªÂä†remote_get_serversÂëΩ‰ª§
- ‚úÖ Ê∑ªÂä†remote_delete_serverÂëΩ‰ª§
- ‚úÖ Ê∑ªÂä†remote_get_cache_statsÂëΩ‰ª§

Èò∂ÊÆµÂÖ≠ÔºöÂâçÁ´ØUIÂÆûÁé∞
- ‚úÖ ÊõøÊç¢WebDAVSettingsÁªÑ‰ª∂
- ‚úÖ ÂÆûÁé∞TabÂàáÊç¢
- ‚úÖ ÂÆûÁé∞ÊúçÂä°Âô®ÂàóË°®
- ‚úÖ ÂÆûÁé∞Ê∑ªÂä†ÂØπËØùÊ°Ü

Èò∂ÊÆµ‰∏ÉÔºöÊµãËØï‰∏éÈ™åËØÅ
- ‚úÖ ÁºñËØëÊµãËØïÈÄöËøá
- ‚úÖ ÂçïÂÖÉÊµãËØïÈÄöËøá
- ‚úÖ Â∫îÁî®ÂêØÂä®È™åËØÅÈÄöËøá

Êñá‰ª∂‰øÆÊîπÊ∏ÖÂçïÔºö
- Êñ∞Âª∫: src-tauri/src/webdav/xml_parser.rs
- Êñ∞Âª∫: src-tauri/src/webdav/remote_adapter.rs
- Êñ∞Âª∫: src-tauri/src/remote_source/mod.rs
- Êñ∞Âª∫: src-tauri/src/remote_source/types.rs
- ‰øÆÊîπ: src-tauri/Cargo.toml
- ‰øÆÊîπ: src-tauri/src/webdav/mod.rs
- ‰øÆÊîπ: src-tauri/src/webdav/client.rs
- ‰øÆÊîπ: src-tauri/src/db.rs
- ‰øÆÊîπ: src-tauri/src/lib.rs
- ÊõøÊç¢: src/components/settings/WebDAVSettings.tsx

ÊÄªËÆ°Ôºö10‰∏™Êñá‰ª∂‰øÆÊîπ/Êñ∞Âª∫

ÂÆûÊñΩÁä∂ÊÄÅÔºö‚úÖ ÊàêÂäüÂÆåÊàê
```

### To-dos

- [ ] Êâ©Â±ïTauriÂëΩ‰ª§ÔºàÊúçÂä°Âô®ÁÆ°ÁêÜ„ÄÅÊâ´Êèè„ÄÅÁºìÂ≠òÔºâ
- [ ] ÂÆûÁé∞ËøúÁ®ãÈü≥‰πêÊ∫êËÆæÁΩÆUIÔºàWebDAV+FTPÁªü‰∏ÄÁïåÈù¢Ôºâ
- [ ] ÈõÜÊàêÂà∞Êí≠ÊîæÂô®ÔºàÁºìÂ≠òÊ£ÄÊü•„ÄÅÊµÅÂºèÊí≠ÊîæÔºâ